---
path: /rust-ownership-wakaran
created: "2023-05-19"
title: Rust ã® æ‰€æœ‰æ¨©ã€å€Ÿç”¨ã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã«ã¤ã„ã¦åˆå¿ƒè€…ç›®ç·šã§èª¬æ˜ã¨æ•´ç†ã‚’è©¦ã¿ã‚‹
visual: "./visual.png"
tags: [rust, ownership]
userId: sadnessOjisan
isFavorite: false
isProtect: false
---

è‡ªåˆ†ã®ãƒ–ãƒ­ã‚°ã‚’è¾¿ã£ã¦ã¿ãŸã¨ã“ã‚ [Rust ã‚’ 2020 å¹´ã«ã¯æ›¸ã„ã¦ã„ã‚‹](https://blog.ojisan.io/rust-buffer-from/)ã‚ˆã†ã ãŒã€åˆå¿ƒè€…ã‚’åä¹—ã‚‰ã›ã¦ã„ãŸã ãã€‚ãªãœãªã‚‰ãƒ–ãƒ­ã‚°ã®ãƒã‚¿ã«ã™ã‚‹ä»¥å¤–ã§ Rust æ›¸ã„ãŸã“ã¨ãªã„ã—ã€ã“ã‚Œã‚‚èª¿ã¹ãªãŒã‚‰æ›¸ã„ã¦ã„ã‚‹ã‹ã‚‰ã ã€‚ã‚‚ã£ã¨ç·´ç¿’ã—ãŸã„ã€ã©ã“ã‹ã« Rust ã‚’æ›¸ã‘ã‚‹æ©Ÿä¼šãªã„ã‹ãªã€œï¾ï¾—ï½¯ï¾ï¾—ï½¯ ğŸ‘€

## ãªãœã‚ã‚Šãµã‚Œã¦ã„ãã†ãªé¡Œæã§æ›¸ãã‹

é¡Œæã¯ã‚ã‚Šãµã‚Œã¦ã„ã‚‹ã—è§£èª¬ã‚‚ãŸãã•ã‚“ã‚ã‚‹ãŒã€ãã‚Œã‚‰ã‚’èª­ã‚“ã§ç†è§£ã§ãã‚‹ã®ã‹ï¼Ÿã¨ã„ã†ç–‘å•ãŒã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€æ‰€æœ‰æ¨©ã€å€Ÿç”¨ã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ è‡ªä½“ã«ã¤ã„ã¦ã®èª¬æ˜ã¯è‡³ã‚‹æ‰€ã§è¦‹ã‚‹ãŒã€ã“ã‚Œã‚‰ãŒç„¡ã„ã¨ä½•ãŒå¤§å¤‰ãªã®ã‹ã€å°å…¥ã™ã‚‹ã“ã¨ã§ä½•ãŒè§£æ±ºã•ã‚Œã‚‹ã‹ãŒã‚ˆãåˆ†ã‹ã‚‰ãªã„ã¨æ€ã†ã‹ã‚‰ã ã€‚å‹¿è«–ã€ãã®ã‚ˆã†ãªç‚¹ã¾ã§è§£èª¬ã—ã¦ãã‚Œã¦ã„ã‚‹ã‚‚ã®ã‚‚ãŸãã•ã‚“ã‚ã‚‹ãŒã€æ­£ç›´ãªã¨ã“ã‚ Not for Me ã ã£ãŸã€‚ä½•ãŒ Not for Me ã ã£ãŸã‹ã¨ã„ã†ã¨ã€C++ ã®çŸ¥è­˜ã‚„ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚µã‚¤ã‚¨ãƒ³ã‚¹ã®çŸ¥è­˜ãŒã‚ã‚‹ã“ã¨ãŒå‰æã«ãªã£ã¦ã„ã‚‹ç‚¹ã ã€‚[ä¸–ã«ã‚ã‚‹ Rust ã®ç´ æ™´ã‚‰ã—ã„æ›¸ç±](https://nostarch.com/rust-rustaceans)ã‚„è¨˜äº‹ã¯ã€åƒ•ã®ã‚ˆã†ãª JavaScript ã‹ã‚‰ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«å…¥ã£ã¦ã€JavaScript ã®ä¸­ã§ç”Ÿãã¦ã„ã‚‹é–‹ç™ºè€…ï¼ˆãã—ã¦ãŠãã‚‰ãã“ã®ãƒ–ãƒ­ã‚°ã®èª­è€…ã®å±æ€§ã¯åƒ•ã¨åŒã˜ãã‚Œã ã¨æ€ã†ï¼‰ã«ã¨ã£ã¦ã¯å…¨ãåˆ†ã‹ã‚‰ãªã„èª¬æ˜ã ã¨æ€ã†ã€‚ã€Œå‚ç…§ã€ãªã‚“ã¦ã‚‚ã®ã‚’ä½¿ã£ãŸã“ã¨ã¯ã“ã‚Œã¾ã§ã®ã‚­ãƒ£ãƒªã‚¢ã§ãªã„ã€‚ãªã®ã§ãã‚“ãªè‡ªåˆ†ã®ç›®ç·šã§ã€ãã‚“ãªè‡ªåˆ†ãŒç´å¾—ã™ã‚‹ã‚ˆã†ãªèª¬æ˜ã‚’ã—ã¦ã¿ã‚ˆã†ã¨æ€ã†ã€‚ã‚‚ã¡ã‚ã‚“ã“ã‚Œã¯è‡ªåˆ†ã®ç†è§£ã®ãŸã‚ã§ã‚ã‚‹ã€‚ã¤ã„ã§ã«èª°ã‹ã®å½¹ã«ç«‹ã¤ã¨å¬‰ã—ã„ã€‚çŸ¥ã‚‰ã‚“ã‘ã©ã€‚

ã‚ã¨ä¸–ã«ã‚ã‚‹èª¬æ˜ãŒåˆ†ã‹ã‚‰ãªã‹ã£ãŸã¨æ›¸ã„ãŸãŒã€TRPL ã®[æ‰€æœ‰æ¨©ã®ç¯€](https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html)ã«ã¯çµæ§‹ã‚ã‹ã‚Šã‚„ã™ãæ›¸ã‹ã‚Œã¦ã„ã‚‹ã—ã€[language reference](https://doc.rust-lang.org/reference/)ã‚‚ã‹ãªã‚Šèª­ã¿ã‚„ã™ã„ã®ã§(ã‹ãã„ã†è‡ªåˆ†ã¯å…¨ç„¶èª­ã‚ã¦ãªã„ãŒ)ã“ã‚Œã¯èª­ã‚€ã¹ãã ã€‚ ã“ã‚Œã‚‰ã¯åƒ•ã¯æœ€åˆå…¨ãåˆ†ã‹ã‚‰ãªã‹ã£ãŸãŒã€ãŸã ä¸€é€šã‚Šå‹‰å¼·ã—ã¦ã‹ã‚‰èª­ã¿ç›´ã™ã¨ã€ã€Œã‚ˆãæ›¸ã‘ã¦ã„ã‚‹ãªãã€ã¨ã„ã†æ„Ÿæƒ³ã«ãªã£ãŸã€‚ãªã®ã§ä¸€å‘¨ç›®ã¯é›£ã—ã„æ°—ãŒã™ã‚‹ï¼ˆåƒ•ã®é ­ãŒæ‚ªã„ã ã‘ã ã£ãŸã‚‰ã™ã¿ã¾ã›ã‚“â€¦ï¼‰ã€‚

## å…è²¬ãƒ»è¬è¾

[Web ã‚µãƒ¼ãƒãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£é€²åŒ–è«– 2023](https://blog.ojisan.io/server-architecture-2023/) ã‚’æ›¸ã„ãŸæ™‚ã¨åŒã˜ãã€ä¸€å¿œ [@mitama_rs](https://twitter.com/mitama_rs) ã«è¦‹ã¦ã‚‚ã‚‰ã£ã¦ã„ã‚‹ã®ã§ã€å¤‰ãªã“ã¨ã¯æ›¸ã„ã¦ã„ãªã„ã¯ãšã ãŒã€å¤‰ãªã“ã¨æ›¸ã„ã¦ã„ãŸã‚‰ã™ã¿ã¾ã›ã‚“ã€‚æ·±å¤œã«ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æŠ¼ã—ä»˜ã‘ãŸè‡ªåˆ†ã®è²¬ä»»ã§ã™ã€‚

ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã¯è‡ªåˆ†ã§æ›¸ã„ãŸã‚‚ã®ä»¥å¤–ã¯å‡ºå…¸ã‚’æ˜è¨˜ã—ã¦ã„ã‚‹ãŒã€è‰¯ã„ä¾‹ãŒæ€ã„ã¤ã‹ãªã‹ã£ãŸç®‡æ‰€ã¯ ChatGPT ã«ç”Ÿæˆã•ã›ã¦ã„ã‚‹ã€‚ä¸€å¿œå‡ºå…¸ãŒã‚ã‚‹ã®ã‹ã¯ç¢ºèªã—ãŸãŒã€ã‚‚ã—ç„¡æ–­ã§å¼•ç”¨ã—ã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚Šãã†ã ã£ãŸã‚‰æ•™ãˆã¦æ¬²ã—ã„ã€‚

## ãªãœæ‰€æœ‰æ¨©ãƒ»å€Ÿç”¨ãƒ»ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒå¿…è¦ã‹

### é€†ã«ãªãœ JavaScript ã« æ‰€æœ‰æ¨©ãƒ»å€Ÿç”¨ãƒ»ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒãªãã¦ã‚‚ä¿ºã¯å›°ã£ã¦ã„ãªã‹ã£ãŸã®ã‹

JavaScript ã« æ‰€æœ‰æ¨©ãƒ»å€Ÿç”¨ãƒ»ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒãªã„ç†ç”±ã¯ç°¡å˜ã§ã€ã€Œå¿…è¦ãªã„ã‹ã‚‰ã€ã ã€‚ãã‚Œã¯ GC ãŒã‚ã‚‹ãŸã‚ã (â€»æ‰€æœ‰æ¨©ã«é–¢ã—ã¦ã¯ä¸€éƒ¨ GC ã¨ã¯é–¢ä¿‚ãªã„éƒ¨åˆ†ã‚‚ã‚ã‚‹ãŒã€æ‰€æœ‰æ¨©ã®æ¦‚å¿µãŒã‚ã‚‹ã¨ GC ã‚’ä¸è¦ã«ã§ãã‚‹ã®ã§æ··ãœã¦ã„ã‚‹ï¼‰ã€‚GC ã¯ ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ç•¥ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒåˆ©ç”¨ã—ãŸãƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’è§£æ”¾ã™ã‚‹ã€‚

GC ã¯é¦´æŸ“ã¿ãŒãªã„äººã¯é¦´æŸ“ã¿ãŒãªã„ã¯ãšãªã®ã§ã€GC ãŒã©ã†ã—ã¦æ¬²ã—ããªã‚‹ã®ã‹ã‚’ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ä»•çµ„ã¿ã‹ã‚‰è¶…ç°¡å˜ã«ã„ã„åŠ æ¸›ãªèª¬æ˜ã‚’ã™ã‚‹ã¨ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ä¸­ã«ã¯ CPU ã¨ãƒ¡ãƒ¢ãƒªãŒã‚ã‚Šã€CPU ãŒãƒ¡ãƒ¢ãƒªã«çŠ¶æ…‹ã‚’ä¿å­˜ã—ãªãŒã‚‰ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã—ã¦ã„ãã€‚ãƒ¡ãƒ¢ãƒªã«ã¯ã‚¹ã‚¿ãƒƒã‚¯ã¨ãƒ’ãƒ¼ãƒ—ãŒã‚ã‚Šã€CPU ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã™ã‚‹ã¨ãã¯ã‚¹ã‚¿ãƒƒã‚¯ã«åˆ©ç”¨ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’ç©ã¿ä¸Šã’ã¦ã„ãï¼ˆãƒ¬ã‚¸ã‚¹ã‚¿ã®ã“ã¨ã¯ä¸€æ—¦å¿˜ã‚Œã¦ãã ã•ã„ï¼‰ã€‚ã“ã“ã§ã„ã†ãƒ‡ãƒ¼ã‚¿ã¨ã¯å¤‰æ•°ã‚„é–¢æ•°ã®ä½ç½®ãªã©ã§ã‚ã‚‹ã€‚ãŸã ã‚¹ã‚¿ãƒƒã‚¯ã¯å¤–éƒ¨ã‹ã‚‰å—ã‘å–ã‚‹ãƒ‡ãƒ¼ã‚¿ã®ã‚ˆã†ã«ã€ã‚µã‚¤ã‚ºãŒèª­ã¿ã«ãã„ãƒ‡ãƒ¼ã‚¿ã¯ç©ã¿ã«ãã„ã€‚ãã®ãŸã‚ãã†ã„ã£ãŸãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã„ãŸã„ã¨ãã¯ãƒ’ãƒ¼ãƒ—ã¨å‘¼ã°ã‚Œã‚‹é ˜åŸŸã‚’ä½¿ã£ã¦ä¿å­˜ã—ã€ãã®ãƒ’ãƒ¼ãƒ—é ˜åŸŸã«å¯¾ã™ã‚‹ãƒã‚¤ãƒ³ã‚¿ã‚’ CPU ã‚„ã‚¹ã‚¿ãƒƒã‚¯ã§åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰èª­ã¿æ›¸ãã—ã¦ã„ã‚‹ã€‚ã¤ã¾ã‚Šãƒ’ãƒ¼ãƒ—ã¯å‹•çš„ã«ç¢ºä¿ã§ãã‚‹é ˜åŸŸã ã€‚ä½¿ã†æ™‚ã¯ malloc ã®ã‚ˆã†ãªï¼ˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼‰é–¢æ•°ã§ç¢ºä¿ã€free ã§è§£æ”¾ã§ãã‚‹ã€‚ãŸã æ¯å›äººåŠ›ã§ã“ã®ä½œæ¥­ã‚’ã™ã‚‹ã®ã¯é¢å€’ãªã®ã§ã€JavaScript ã®ã‚ˆã†ãªè¨€èªã§ã¯ GC ã¨ã„ã†ä»•çµ„ã¿ãŒä½¿ã‚ã‚Œã‚‹ã€‚GC ã«ã¤ã„ã¦å¾Œã§åˆ¥ã®è³‡æ–™ã«èª¬æ˜ã‚’ä¸¸æŠ•ã’ã—ã¦ä¸€è¨€ã ã‘ã§èª¬æ˜ã™ã‚‹ãŒã€ä¸€èˆ¬çš„ã«ã¯ GC ãŒã‚ã‚Œã° GC ã«ã‚ˆã£ã¦ãƒ¡ãƒ¢ãƒªãŒç®¡ç†ã•ã‚Œã‚‹ã®ã§æ‰€æœ‰æ¨©ãƒ»å€Ÿç”¨ãƒ»ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ãªãã¦ã‚‚è‰¯ã„ã®ã§ã‚ã‚‹ã€‚

ã“ã®ã‚ãŸã‚Šã¯ [ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ãªãœå‹•ãã®ã‹ ç¬¬ 3 ç‰ˆ çŸ¥ã£ã¦ãŠããŸã„ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®åŸºç¤çŸ¥è­˜](https://amzn.asia/d/h3UOqRW) ãŒåˆ†ã‹ã‚Šã‚„ã™ã‹ã£ãŸè¨˜æ†¶ãŒã‚ã‚‹ã€‚

### ãã‚‚ãã‚‚å‚ç…§ãªã‚“ã¦ã‚‚ã®ãŒãªã‘ã‚Œã°æ‰€æœ‰æ¨©ãªã‚“ã¦ã„ã‚‰ãªã„

ã“ã“ã§å‚ç…§ã«ã¤ã„ã¦è€ƒãˆã‚‹ãŒã€å‚ç…§ã¨ã¯ä½•ã‹ã®èª¬æ˜ã¯å…·ä½“ä¾‹ã‚’å…ˆã«è¦‹ã›ãŸæ–¹ãŒæ—©ã„ã®ã§èª¬æ˜ã‚’å¾Œå›ã—ã«ã™ã‚‹ã€‚
ä¾‹ãˆã° Python ã§ã€

```python
a = []
b = a
a.append(1)
```

ã¨æ›¸ã„ã¦å®Ÿè¡Œã™ã‚‹ã¨ã€

```
>>> a
[1]
>>> b
[1]
```

ã¨ãªã‚‹ã€‚a ã« append ã—ãŸã‚‰ b ã‚‚å¤‰ã‚ã£ã¦ã—ã¾ã£ãŸã€‚

ã“ã‚Œã¯ a ã¨ b ãŒåŒã˜å‚ç…§ã‚’æŒã£ã¦ã„ã‚‹ãŸã‚ã ã€‚ã“ã“ã§ã„ã†å‚ç…§ã¨ã¯ãƒ¡ãƒ¢ãƒªã®ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆã„ã„åŠ æ¸›ã«èª¬æ˜ã™ã‚‹ã¨ä½æ‰€ï¼‰ã¨è¦‹ã¦è‰¯ã„ã€‚ã¤ã¾ã‚Š a ã‚‚ b ã‚‚ãƒ¡ãƒ¢ãƒªé ˜åŸŸã®åŒã˜ç®‡æ‰€ã‚’æŒ‡ã—ã¦ã„ã‚‹ã®ã§ã‚ã‚‹ã€‚ã‚‚ã—åˆ¥ä½“ã¨ã—ã¦è¤‡è£½ã—ãŸã‘ã‚Œã°ã€æ–°ã—ããƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’ç¢ºä¿ã—ã¦ã€ãã“ã‚’ä½¿ã£ã¦ a ã¨ b ã‚’åŒºåˆ¥ï¼ˆç•°ãªã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä¸ãˆã‚‹ï¼‰ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸã€‚ã“ã®ã‚ˆã†ãªåŒºåˆ¥ã‚’ä½œã‚‹æ–¹æ³•ã¯ã‚¯ãƒ­ãƒ¼ãƒ³ã‚„ã‚³ãƒ”ãƒ¼ã¨å‘¼ã°ã‚Œã‚‹ã€‚

ãªã®ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã™ã‚‹ã«ã‚ãŸã£ã¦ã¯ã‚¯ãƒ­ãƒ¼ãƒ³ã—ãŸæ–¹ãŒè‰¯ã„ã‚ˆã†ã«æ€ãˆã‚‹ãŒã€å‚ç…§ã«ã‚‚ãƒ¡ãƒªãƒƒãƒˆã¯ã‚ã‚‹ã€‚ã‚¯ãƒ­ãƒ¼ãƒ³ã‚’ã›ãšã«å‚ç…§ã‚’ä½¿ã†ã¨ã€ãƒ¡ãƒ¢ãƒªç¢ºä¿ãŒä¸è¦ã«ãªã‚‹ã®ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚„ãƒ¡ãƒ¢ãƒªã®ä½¿ç”¨ç‡ãŒæ¸›å°‘ã—ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯åŠ¹ç‡çš„ã«ãªã‚‹ã€‚ãŸã¨ãˆã°ãƒ‡ãƒ¼ã‚¿ã‚’å…¨éƒ¨ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦ä½¿ã£ã¦ã„ã‚‹ã¨ãã‚Œã¯ãƒ¡ãƒ¢ãƒªã®ç„¡é§„ä½¿ã„ã ã€‚

### ãƒ¡ãƒ¢ãƒªç®¡ç†ã‚’ GC ã«ä»»ã›ãŸããªã„

ãŸã ã—å‚ç…§ã‚’ä½¿ã†ã¨ mutation ãŒæ³¢åŠã—ã¦å›°ã‚‹ã‚±ãƒ¼ã‚¹ã¨ã„ã†ã®ã¯ã‚ã‚Šã€ã¿ãªã•ã‚“ã‚‚çµŒé¨“ã—ãŸã“ã¨ã‚‚ã‚ã‚‹ã ã‚ã†ã€‚ãã®ãŸã‚ã«ã‚¯ãƒ­ãƒ¼ãƒ³ã‚’ä½¿ã„ãŸã„ãŒã€ã‚¯ãƒ­ãƒ¼ãƒ³ã¯ãƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’ç¢ºä¿ã—ã¦ã„ãã®ã§ã€ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã™ãã‚‹ã¨ã„ã¤ã‹ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢çš„ãªé™ç•Œã«è¡Œãå½“ãŸã‚‹ã€‚ãã®ãŸã‚ä½¿ã‚ãªã„ãƒ¡ãƒ¢ãƒªé ˜åŸŸã¯å®šæœŸçš„ã«è§£æ”¾ã—ã¦ã„ã‹ãªã„ã¨ã„ã‘ãªã„ã€‚ãã®è§£æ±ºæ³•ã¨ã—ã¦ GC ãŒã‚ã‚‹ã€‚

GC ã®è©³ã—ã„èª¬æ˜ã¯ MS Learn ã‚’ã¿ã¦æ¬²ã—ã„ã€‚ã„ã¾èª¬æ˜ã™ã‚‹ã¨ãã‚Œã ã‘ã§åˆ¥ã®è¨˜äº‹ã«ãªã‚‹ã€‚

FYI: https://learn.microsoft.com/ja-jp/dotnet/standard/garbage-collection/fundamentals

è¦ã™ã‚‹ã«ã€å®šæœŸçš„ã«ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼ãŒä¸è¦ãªãƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’æ•´ç†ã—ã¦ãã‚Œã‚‹ä»•çµ„ã¿ã ã€‚

ã“ã‚Œã¯ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®è§£æ¶ˆã‚„ã€ãƒ¡ãƒ¢ãƒªã®äºŒé‡é–‹æ”¾ã‚’é˜²ãæ‰‹ã«ãªã‚‹ã®ã ãŒã€GC ã¯ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰è¦‹ã‚‹ã¨è»½å¾®ã ãŒã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‹ã‚‰è¦‹ã‚‹ã¨ï¼‰ã‚³ã‚¹ãƒˆãŒé‡ã„ã®ã§ã€å¯èƒ½ãªã‚‰é¿ã‘ãŸã„ã¨æ€ã£ã¦ã„ã‚‹äººã‚‚ã„ã‚‹ã€‚ã§ã¯ã€GC ã‚’ä½¿ã‚ãšã«ãƒ¡ãƒ¢ãƒªã‚’ç®¡ç†ã™ã‚‹ã¨ã©ã†ã„ã†æ–¹æ³•ãŒã‚ã‚‹ã‹ã‚’è€ƒãˆã¦ã¿ã‚‹ã¨ã€ã¾ãšæ€ã„ã¤ãã®ã¯æ‰‹ã§ç®¡ç†ã ã‚ã†ã€‚ã ãŒã“ã‚Œã¯è¾›ã„ã€‚ï¼ˆé€†ã« GC ã¯æ‰‹ã§ç®¡ç†ã™ã‚‹ã®ã‚’é¿ã‘ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ï¼‰

### æ‰‹ã§ãƒ¡ãƒ¢ãƒªç®¡ç†ã‚’ã™ã‚‹ã¨ä½•ãŒè¾›ã„ã®ã‹

ä¾‹ãˆã° C è¨€èªã§ã¯äººé–“ãŒæ‰‹ã§ãƒ¡ãƒ¢ãƒªã‚’ç®¡ç†ã™ã‚‹ã€‚malloc ã§ãƒ’ãƒ¼ãƒ—ã‚’ç¢ºä¿ã—ã€free ã§è§£æ”¾ã™ã‚‹ã€‚ã“ã‚Œã¯ä¸€è¦‹ã™ã‚‹ã¨ GC ã—ãªã„ã®ã§ã¨ã¦ã‚‚è‰¯ã„æ–¹æ³•ã«æ€ãˆã‚‹ã€‚ãŸã ã“ã‚Œã¯å¤§ããªå•é¡ŒãŒã‚ã‚Šã€ä½¿ã„çµ‚ã‚ã£ã¦ã„ãªã„ã®ã« free ã™ã‚‹ã¨ç„¡åŠ¹ãªãƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ï¼ˆãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ãƒã‚¤ãƒ³ã‚¿ï¼‰ã‚’ä½œã£ã¦ã—ã¾ã£ãŸã‚Šã€è§£æ”¾å¿˜ã‚Œã®ãƒ¡ãƒ¢ãƒªãŒç©ã¿é‡ãªã£ã¦ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã«ç¹‹ãŒã£ãŸã‚Šã™ã‚‹ã€‚äººæ‰‹ã§ã‚„ã‚‹ãŸã‚ãƒŸã‚¹ãŒã‚ã‚‹ã ã‚ã†ã—ã€ãã®ãƒŸã‚¹ã‚‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®åœæ­¢ã«ã¤ãªãŒã‚Šã‚„ã™ã„ã€‚

### ãƒ¡ãƒ¢ãƒªç®¡ç†ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ä»»ã›ã‚‹

ã“ã‚Œã«å¯¾ã—ã¦ Rust ãŒã¨ã£ãŸã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ãƒ¡ãƒ¢ãƒªã‚’ç®¡ç†ã•ã›ã‚‹æ–¹æ³•ã§ã‚ã‚‹ã€‚ã‚¢ã‚¤ãƒ‡ã‚¢ã¯ RAII ã¨æ‰€æœ‰æ¨©ã«ã‚ã‚‹

#### RAII

RAII ã¨ã¯ Resource Acquisition is Initialization ã®ç•¥ã§ã€ãƒªã‚½ãƒ¼ã‚¹ç¢ºä¿ã‚’åˆæœŸåŒ–æ™‚ã«è¡Œã†ã€‚åå¯¾ã«ã„ã†ã¨ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ãƒªã‚½ãƒ¼ã‚¹ã®è§£æ”¾ã‚’è¡Œã†ã€‚ã“ã®ã‚ˆã†ãªåˆæœŸåŒ–ã¨çµ‚äº†æ™‚ã«ãƒ¡ãƒ¢ãƒªã®ç¢ºä¿ã¨è§£æ”¾ã‚’ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒå·®ã—è¾¼ã‚€ã‚ˆã†ã«ã™ã‚‹ã€‚ã“ã‚Œã¯ãƒ¡ãƒ¢ãƒªã®äººæ‰‹ç®¡ç†ã‚„ GC ã¨ã¯ã¾ãŸç•°ãªã£ãŸã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã‚ã‚Šã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«é ¼ã‚‹æ–¹æ³•ã§ã‚ã‚‹ã€‚RAII ã«ã‚ˆã‚Šãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã¯é˜²ã’ã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚

ã“ã®ã¨ãã«ã‚‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ç”Ÿãã¦ãã‚‹ã€‚RAII ã¯å¤‰æ•°ãŒ drop ã—ãŸã¨ãã« free ã‚’å‘¼ã¶ä»•çµ„ã¿ã¨ã‚‚è¨€ãˆã‚‹ã€‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯å¤‰æ•°ã®ç”Ÿå­˜æœŸé–“ã§ã‚ã‚Šã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒ drop ã‚’å·®ã—è¾¼ã‚€ãŸã‚ã®æƒ…å ±ã«ã‚‚ãªã£ã¦ã„ã‚‹ã€‚ï¼ˆã¤ã¾ã‚Šãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯å‚ç…§ã ã‘ã®ã‚‚ã®ã§ã¯ãªã„ï¼‰

#### æ‰€æœ‰æ¨©ã€å‚ç…§ã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ 

ï¼ˆä¸Šã§ã¿ãŸã‚ˆã†ã«ç¾å®Ÿã«ã¯ãã†ãªã‚‰ãªã„ã‚ˆã†ãªå·¥å¤«ãŒã•ã‚Œã¦ã„ã‚‹ãŒã€ï¼‰RAII ã‚’ã€Œã‚¹ã‚³ãƒ¼ãƒ—ã®å‡ºå…¥ã‚Šã«åˆã‚ã›ã¦ãƒ¡ãƒ¢ãƒªã®ç¢ºä¿ãƒ»è§£æ”¾ã‚’è‡ªå‹•ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒå·®ã—è¾¼ã‚€æ©Ÿèƒ½ã€ã¨è§£é‡ˆã™ã‚‹ã®ã§ã‚ã‚Œã°ã€ã¾ã åˆ©ç”¨ã—ã¦ã„ã‚‹ã®ã«ãã®å¤‰æ•°ãŒä½¿ã£ã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’è§£æ”¾ã—ã€ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ãƒã‚¤ãƒ³ã‚¿ã‚’ä½¿ã†ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’ã‹ã‘ã¦ã—ã¾ã†ã€‚ã¾ãŸ RAII ã¯çµå±€ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã™ã‚‹ã®ã§ã‚¨ã‚³ã§ã¯ãªã„ã€‚ãƒ¡ãƒ¢ãƒªè² è·ã¯é«˜ã¾ã‚‹ã€‚ãªã®ã§å®‰å…¨ã«å‚ç…§ã‚’ä½¿ã„ãŸã„ã€‚ãã®ãŸã‚ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã§å¤‰æ•°ã®ç”Ÿå­˜ç¯„å›²ã‚’æ¤œæŸ»ã—ã€ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ãƒã‚¤ãƒ³ã‚¿ãŒç™ºç”Ÿã—ãªã„ã‚ˆã†ã«æ¤œæŸ»ã™ã‚‹æ–¹æ³•ã‚’è€ƒãˆãŸã„ã€‚ãã®ãŸã‚ã®ã‚¢ã‚¤ãƒ‡ã‚¢ãŒæ‰€æœ‰æ¨©ã¨å‚ç…§ã¨ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã«ã‚ã‚‹ã€‚

### å®‰å…¨ã«å‚ç…§ã‚’ä½¿ã„ãŸã„

ã¾ãšå‚ç…§ã¯å±é™ºã¨ã„ã†èªè­˜ãŒå¿…è¦ã§ã‚ã‚‹ã€‚å‚ç…§å…ˆã‚’æ›¸ãæ›ãˆã‚‹ã¨ã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ä»–ã®å‚ç…§ã«ã‚‚å½±éŸ¿ãŒã‚ã‚‹ã€‚ã¾ãŸä¼¼ãŸå•é¡Œã«ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ç’°å¢ƒã§ãƒªã‚½ãƒ¼ã‚¹ã‚’åŒæ™‚ã«è¤‡æ•°äººãŒè§¦ã‚‹ã¨å±é™ºã¨ã„ã†ã®ã‚‚ã‚ã‚‹ã€‚ä¾‹ãˆã°å‘¼ã°ã‚ŒãŸé †åºã«ã‚ˆã£ã¦çµæœãŒå¤‰ã‚ã£ãŸã‚Šã€ãã®ãƒªã‚½ãƒ¼ã‚¹ãŒå­˜åœ¨ã—ãªã„å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚ãã®ãŸã‚ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒªã‚½ãƒ¼ã‚¹ã®è§¦ã‚Œã‚‹æ¨©åˆ©ã‚„ç”Ÿå­˜ç¯„å›²ã¨ã„ã†ã®ã‚’æ°—ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚

Rust ã¯ã“ã®æ¨©åˆ©ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã«æ‰€æœ‰æ¨©ã¨ã„ã†è€ƒãˆã‚’æŒã¡è¾¼ã‚€ã€‚ãã‚Œã¯ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’è§¦ã‚Œã‚‹æ¨©åˆ©ã¨æ€ãˆã°ã‚ˆãã€ãã®æ¨©åˆ©ã®ç§»ã—æ›¿ãˆã‚„æ¨©åˆ©ãŒæ­£ã—ãä½¿ãˆã‚Œã¦ã‚‹ã‹ã®ãƒã‚§ãƒƒã‚¯ã‚’å«ã‚€ã€‚ä¾‹ãˆã° Rust ã® = ã«ãŠã„ã¦ã¯ãƒ ãƒ¼ãƒ–ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¨ã‚³ãƒ”ãƒ¼ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ãŒã‚ã‚‹ã€‚

ä¾‹ãˆã°æ–‡å­—åˆ—ã‚’å¤‰æ•°ã«ä»£å…¥ã—ãŸå ´åˆã€ãƒ’ãƒ¼ãƒ—ã«ä¿å­˜ã•ã‚ŒãŸæ–‡å­—åˆ—ã®å®Ÿä½“ã®å…ˆé ­ã¸ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚„é•·ã•ã®ã¿ãŒå¤‰æ•°ã«ä»£å…¥ã•ã‚Œã¦ã„ã‚‹ã€‚ã“ã®å¤‰æ•°ã«å¯¾ã™ã‚‹ = ã‚’ã‚³ãƒ”ãƒ¼ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¨ã—ã¦ä½¿ãˆã°ã€ãƒ‡ãƒ¼ã‚¿ã®å®Ÿä½“ã”ã¨ãƒ’ãƒ¼ãƒ—ã«è¤‡è£½ã—ã¦å‹•ããŒã“ã‚Œã¯ã‚¨ã‚³ã§ã¯ãªã„ã€‚ãªã®ã§æ–‡å­—åˆ—ã®å…ˆé ­ã¸ã®å‚ç…§ã¨é•·ã•ã ã‘ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚ãã®ã¨ãã€å…ƒã®å¤‰æ•°ã¨æ–°ã—ã„å¤‰æ•°ã¨ã§æ–‡å­—åˆ—ã¸ã®å‚ç…§ã‚’åŒæ™‚ã«è§¦ã‚Œã‚‹ã¨äº‹æ•…ãŒèµ·ãã‚‹ã®ã§ã€ã“ã®å‚ç…§ã‚’å¤‰æ•°ã‚’çµŒç”±ã—ã¦è§¦ã‚Œã‚‹æ¨©åˆ©ã¨ã—ã¦æ‰€æœ‰æ¨©ãŒã‚ã‚Šã€ã“ã®æ‰€æœ‰æ¨©ã‚’ç§»ã™ãŸã‚ã® = ãŒãƒ ãƒ¼ãƒ–ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã ã€‚Rust ã® = ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ãƒ ãƒ¼ãƒ–ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã ãŒã€ãã®å¯¾è±¡ãŒè‡ªå‹•ã§ clone ã™ã‚‹ copy ã¨ã„ã†æ©Ÿèƒ½ã‚’æŒã£ã¦ã„ã‚Œã°ã€= ã®æ„å‘³ã‚’ã‚³ãƒ”ãƒ¼ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¨ã—ã¦æ‰±ãˆã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚

Rust ã§ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯åŠ¹ç‡ã‚’è€ƒæ…®ã—ã¦ã‚³ãƒ”ãƒ¼ã‚’é¿ã‘ã¦ã„ã‚‹ã€‚ãƒ’ãƒ¼ãƒ—ã«ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿(ãã‚Œã‚’æŒ‡ã—ã¦ã„ã‚‹å¤‰æ•°) ã«å¯¾ã—ã¦ = ã‚’ä½¿ã£ãŸå ´åˆã€ç§»ã•ã‚ŒãŸã‚‚ã®ã¯ãƒ‡ãƒ¼ã‚¿ã®å®Ÿæ…‹ã§ã¯ãªãå‚ç…§ã§ã‚ã‚‹ã€‚ãã—ã¦æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ãã®å‚ç…§ã‚’è§¦ã‚Œã‚‹ä¸»ä½“ã‚’ä¸€ã¤ã ã‘ã«é™ã£ã¦ã„ã‚‹ã®ã§ã‚ã‚‹ã€‚

```
let s1 = String::from("hello hello hello hello hello hello");
let s2 = s1;
```

ï¼ˆã¡ãªã¿ã« hello hello hello hello hello hello ã¨ã—ãŸã®ã¯ã€çŸ­ã„æ–‡å­—åˆ—ã ã¨ç›´æ¥ã‚¢ã‚»ãƒ³ãƒ–ãƒªã«ãƒªãƒ†ãƒ©ãƒ«ã¨ã—ã¦åŸ‹ã‚è¾¼ã¾ã‚Œã¦ã—ã¾ã†ãŸã‚ã ã€‚é•·ã„æ–‡å­—åˆ—ã‹ã€æ¨™æº–å‡ºåŠ›ã§å—ã‘å–ã‚‹ã‹ã€Box ã§åŒ…ã‚€ã‹ã‚’ã—ãªã„ã¨ãƒ’ãƒ¼ãƒ—ã«è¼‰ã£ã¦ãã‚Œãªã„ã€‚ã“ã®æŒ™å‹•ã¯ https://godbolt.org/ ã§éŠã¶ã¨è©¦ã›ã‚‹ã€‚ï¼‰

ãã®ãŸã‚ã« = ã‚’ãƒ ãƒ¼ãƒ–ã¨ã—ã¦ä½¿ã†ã“ã¨ã§ s1 ãŒæŒã£ã¦ã„ãŸãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹ æ‰€æœ‰æ¨©ã‚’ s2 ã«ç§»ã—ã€s1 ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹ã€‚ãã®çµæœ

```
let s1 = String::from("hello hello hello hello hello hello"");
let s2 = s1;
println!("{}, world!", s1);
```

ã¯ã€

```
error[E0382]: use of moved value: `s1`
              (ãƒ ãƒ¼ãƒ–ã•ã‚ŒãŸå€¤ã®ä½¿ç”¨: `s1`)
 --> src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value used here after move
  |                               (ãƒ ãƒ¼ãƒ–å¾Œã«ã“ã“ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™)
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
    (æ³¨é‡ˆ: ãƒ ãƒ¼ãƒ–ãŒèµ·ããŸã®ã¯ã€`s1`ãŒ`std::string::String`ã¨ã„ã†
    `Copy`ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ãªã„å‹ã ã‹ã‚‰ã§ã™)
```

ã¨ã—ã¦ã‚¨ãƒ©ãƒ¼ã«ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚ã“ã‚ŒãŒã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã“ã¨ã§ã€å½¹ç›®ã‚’çµ‚ãˆãŸå¤‰æ•°ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’é˜²ã„ã§ã„ã‚‹ã€‚

Rust ã®åŸºæœ¬çš„ãªã‚¢ã‚¤ãƒ‡ã‚¢ã¨ã¯æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã§ãƒ‡ãƒ¼ã‚¿ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©ã‚’ç®¡ç†ã—ã¤ã¤ã€å‚ç…§ã®ç”Ÿå­˜ç¯„å›²ã‚’ã¿ã¦ã€ç„¡åŠ¹ãªã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã§é˜²ãã“ã¨ã§ã‚ã‚‹ã€‚ãã®ç”Ÿå­˜ç¯„å›²ã®ã“ã¨ã¯ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¨å‘¼ã°ã‚Œã¦ã„ã‚‹ã€‚

## ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¨ã¯ä½•ã‹

Rust ã«ãŠã‘ã‚‹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¨ã¯å¤‰æ•°ã®ç”Ÿå­˜æœŸé–“ã§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç›®ã«ã¯å‚ç…§ã®ç”Ÿå­˜æœŸé–“ã¨ã—ã¦ç¾ã‚Œã‚‹ã€‚å‚ç…§ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ã€ã‚ˆã

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```

ã®ã‚ˆã†ã«è¡¨ç¾ã•ã‚Œã‚‹ã€‚

https://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html

ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ `'a ` ã®ã‚ˆã†ãªæ³¨é‡ˆã§è¡¨ç¾ã•ã‚Œã‚‹ã€‚a ãªã©æ–‡å­—ã¯ã€åŒ¿åãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ  `_` ã¨ `static` ä»¥å¤–ã§ã‚ã‚Œã°ãªã‚“ã§ã‚‚è‰¯ã„ã€‚`' ` ãŒã‚ã‚Œã°è‰¯ã„ã€‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯å‹ã®ä¸€ç¨®ã§ã‚ã‚Šã€&i32 ã¨ã„ã†å‚ç…§ã«ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’ä»˜ã‘ã‚‹ã«ã¯ &'a i32, &'a mut i32 ã®ã‚ˆã†ã«ä½¿ã†ã€‚ã“ã‚Œã¯æ§‹é€ ä½“ã®å®šç¾©ã‚„é–¢æ•°ã®å¼•æ•°ã§ä½¿ãˆã‚‹ã€‚
ã“ã‚Œã¯æ˜ç¤ºã—ãªãã¦ã‚‚

```rust
fn hoge(fuga: &str) {}
```

ã®ã‚ˆã†ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚ã—ã‹ã—

```rust
struct Hoge {
    hoge: &str,
}
```

ã¯ã§ããšã€

```rust
struct Hoge<'a> {
    hoge: &'a str,
}
```

ã¨ã—ãªã„ã¨ã„ã‘ãªã‹ã£ãŸã‚Šã€

```rust
fn hoge(fuga: &str) {}
```

ã¯å¯èƒ½ã§ã‚‚

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

ãŒã§ããšã€

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

ã¨ã—ãªã„ã¨ã„ã‘ãªã„ãªã©ã„ãã¤ã‹ãƒ«ãƒ¼ãƒ«ã‚„è¦å‰‡ãŒã‚ã‚‹ã€‚

ã¾ãšå‰æã¨ã—ã¦ã€çœç•¥ã§ãã‚‹ã®ã¯é–¢æ•°ã®å¼•æ•°ã¨æˆ»ã‚Šå€¤ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã ã€‚ãã—ã¦ãã‚Œã‚‰ã®å¼•æ•°ã¨æˆ»ã‚Šå€¤ã«ã¤ããƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’å…¥åŠ›ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã€å‡ºåŠ›ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¨å‘¼ã¶ã®ã§ã‚ã‚Œã°

1. å„å…¥åŠ›ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã«å¯¾ã—ã¦ã€ãã‚Œãã‚Œç•°ãªã‚‹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹
2. å…¥åŠ›ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒ 1 ã¤ãªã‚‰ã€ãã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒã™ã¹ã¦ã®çœç•¥ã•ã‚ŒãŸå‡ºåŠ›ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹
3. å…¥åŠ›ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒè¤‡æ•°ã‚ã‚Šã€`*self` ã‚‚ã—ãã¯ `&self` ãŒå«ã¾ã‚Œã¦ã„ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã®å ´åˆã€self\*ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒã™ã¹ã¦ã®çœç•¥ã•ã‚ŒãŸå‡ºåŠ›ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹

ã¨ã„ã†è¦å‰‡ãŒé©ç”¨ã•ã‚Œã‚‹ã€‚

è©³ã—ãã¯ https://doc.rust-jp.rs/rust-nomicon-ja/lifetime-elision.html ãªã©ã‚’è¦‹ã‚‹ã¨è‰¯ã„ã ã‚ã†ã€‚

ã“ã®è¦å‰‡ã«å½“ã¦ã¯ã¾ã‚‰ãªã„ã®ã§

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã€

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

ã¨ã—ãªã„ã¨ã„ã‘ãªã„ã€‚â€™a ã¯ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨å‘¼ã°ã‚Œã€ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã§ã‚ã‚Šã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¨ã‚‚å‘¼ã°ã‚Œã‚‹ã€‚ã“ã‚ŒãŒæ„å‘³ã™ã‚‹ã¨ã“ã‚ã¯ã€å…¥åŠ›ã¨åŒã˜ç”Ÿå­˜ç¯„å›²ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’æŒã£ãŸå‚ç…§ã‚’æˆ»ã—ã¦ãã‚Œã‚‹ã“ã¨ã ã€‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒãªã„ã¨ if ãƒ–ãƒ­ãƒƒã‚¯ã¨ else ãƒ–ãƒ­ãƒƒã‚¯ã®ã©ã¡ã‚‰ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã‹åˆ†ã‹ã‚‰ãªã„ã®ã§æˆ»ã‚Šå€¤ã®å‹ã‚’ã©ã†ã—ãŸã‚‰ã„ã„ã‹åˆ¤æ–­ã§ããªã„ã®ã§ã‚ã‚‹ã€‚x ã¨ y ã§é•ã†ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’æ¸¡ã™ã“ã¨ã‚‚ã§ãã¦ã—ã¾ã†ã®ã§ã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ çœç•¥è¨˜æ³•ãŒä½¿ãˆãªã„ã®ã‚‚ç†ã«ã‹ãªã£ã¦ã„ã‚‹ã€‚ã¨ã„ã†ã‚ˆã‚Šç„¡ç†çŸ¢ç† ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ é©ç”¨è¦å‰‡ã‚’å½“ã¦ã¯ã‚ã‚‹ã¨ x, y ã§ç•°ãªã‚‹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒå‰²å½“ãŸã£ã¦ã—ã¾ã†ã®ã§ã€if ã®çµæœãŒã©ã£ã¡ã§å‡ºåŠ›ã•ã‚Œã‚‹ã‹åˆ†ã‹ã‚‰ãªãã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ããªã„ã€‚

ã¨ã‚‚ã‚ã‚Œã€ã“ã“ã§ã¯ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯å¤‰æ•°ã®æœ‰åŠ¹ç¯„å›²ã¨æ€ãˆã°è‰¯ã„ã€‚

## ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®è¨ˆç®—ãƒ»æ¤œè¨¼ã‚’ã©ã®ã‚ˆã†ã«ã—ã¦è¡Œã†ã‹

ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯å¤‰æ•°ã®ç”Ÿå­˜æœŸé–“ã‚’è¡¨ã™ã‚‚ã®ã ã€‚ã“ã‚Œã®ãŠã‹ã’ã§ç„¡åŠ¹ãªå‚ç…§ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚å…·ä½“çš„ã«ã©ã®ã‚ˆã†ã«ä½¿ã‚ã‚Œã‚‹ã®ã‹è¦‹ã¦ã„ã“ã†ã€‚

### ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®é•·ã•ã‚’ãƒªãƒ¼ã‚¸ãƒ§ãƒ³æ¨è«–ã§æ±ºã‚ã‚‹

Rust ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®æ±ºã¾ã‚Šæ–¹ã¯é›£ã—ã„ã€‚æ™®é€šã«è€ƒãˆã‚‹ã®ã§ã‚ã‚Œã°ã€ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‚’ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¨è€ƒãˆã‚‰ã‚Œã‚‹ã€‚ã“ã‚Œã¯ Lexical Scope ã¨ã‚‚å‘¼ã°ã‚Œã€Edition 2015 ã¾ã§ã¯ã“ã®è€ƒãˆæ–¹ã ã£ãŸã€‚
ã—ã‹ã—ã€ã„ã¾ã¯ã‚³ãƒ¼ãƒ‰ã®æ„å‘³ã‚’åŠ å‘³ã—ã¦ãã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®é•·ã•ãŒæ±ºã¾ã‚Šã€ã“ã®ä»•çµ„ã¿ã¯ãƒªãƒ¼ã‚¸ãƒ§ãƒ³æ¨è«–ã¨ã‚‚å‘¼ã°ã‚Œã‚‹ã€‚non-lexical lifetimesï¼ˆNLLï¼‰ã¨ã‚‚å‘¼ã°ã‚Œã€é•·ã„ RFC ãŒã‚ã‚‹ã€‚ã‚‚ã¡ã‚ã‚“åƒ•ã¯èª­ã‚“ã§ã„ãªã„ã€‚

<https://rust-lang.github.io/rfcs/2094-nll.html>

ã“ã®è¾ºã‚Šã¯

- https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes
- https://qiita.com/_EnumHack/items/8b6ecdeb52e69a4ff384

ã‚ãŸã‚Šã§è§£èª¬ã•ã‚Œã¦ã„ã‚‹ã®ã§ã“ã¡ã‚‰ã‚’èª­ã‚“ã§æ¬²ã—ã‹ã£ãŸã‚Šã€å¾Œè€…ã‚’åŸ·ç­†ã—ãŸ [@mitama_rs](https://twitter.com/mitama_rs) ã«è§£èª¬ã—ã¦ã‚‚ã‚‰ã„ãŸã„ã€‚è‡ªåˆ†ã§ã‚‚è§£èª¬ã‚’æ›¸ã“ã†ã¨ã—ãŸãŒã¨ã“ã‚ã ãŒåƒ•ãŒ Rust ã‚’æ›¸ãå§‹ã‚ãŸæ™‚ã«ã¯ã™ã§ã« NLL ã ã£ãŸã®ã§ å½“æ™‚ã®å•é¡Œç‚¹ãŒã‚ˆãåˆ†ã‹ã‚‰ãªã‹ã£ãŸã€‚

ãŸã  control-flow graph ã‚’ä½¿ã£ãŸè§£æã«ãªã£ãŸã¨ã‚ã‚‹ã®ã§ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’ã‚°ãƒ©ãƒ•ã§è¡¨ç¾ã—å¾Œæ–¹è§£æã§ãƒ‡ãƒ¼ã‚¿ã®å¤‰åŒ–ã‚’è¾¿ã£ã¦ live variable è§£æãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã¯ãšã§(ã£ã¦ ChatGPT ãŒè¨€ã£ã¦ãŸ)ã€å¤‰æ•°ã®ç”Ÿå­˜ç¯„å›²ã¯æ˜ç¢ºã«ã§ãã€control-flow graph ã®å°å…¥ã§ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ åˆ¤å®šã®ç²¾åº¦ãŒã‚ãŒã‚‹ã®ã¯ç›´æ„Ÿã«ã‚‚åˆã†ã€‚

æ­£ç›´ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒã©ã®ã‚ˆã†ã«æ±ºã¾ã‚‹ã®ã‹åƒ•ã«ã¯åˆ†ã‹ã‚‰ãªã„ãŒã€Rust ã¯ã“ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’ä½¿ã£ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒæ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã«é•åã—ã¦ã„ãªã„ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ã§ã‚ã‚‹ã€‚ãã®ãƒã‚§ãƒƒã‚¯ã§ã¯å¤§ã¾ã‹ã«æ¬¡ã®ã“ã¨ã‚’ã™ã‚‹ã€‚

### é‰„å‰‡ï¼‘: å¯¿å‘½ã®é•·ã„ã‚‚ã®ãŒçŸ­ã„ã‚‚ã®ã‚’å‚ç…§ã—ã¦ã¯ã„ã‘ãªã„

Rust ã«ãŠã‘ã‚‹æ‰€æœ‰æ¨©ã®ä¸€ç•ªã®ãƒ«ãƒ¼ãƒ«ã¯ã€ã€Œç”Ÿå­˜æœŸé–“ã®é•·ã„ã‚‚ã®ãŒã€çŸ­ã„ã‚‚ã®ã‚’å‚ç…§ã—ã¦ã¯ã„ã‘ãªã„ã€ã ã‚ã†ã€‚

```rust
{
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // ---------+
```

<https://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html>

å¤‰æ•° r ã®æ–¹ãŒé•·ã„é–“ç”Ÿãæ®‹ã£ã¦ã„ã‚‹ãŒã€ã“ã‚ŒãŒ x ã®å‚ç…§ã‚’æŒã£ã¦ã„ã‚‹ã€‚ã“ã‚Œã¯ã€ã‚³ãƒ¼ãƒ‰ã®å®Ÿè¡ŒãŒ x ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ é ˜åŸŸã‚’å‡ºãŸæ™‚ã« r ãŒå‚ç…§ã—ã¦ã—ã¾ã†ã¨ x ãŒç”Ÿãæ®‹ã£ã¦ã„ãªã‘ã‚Œã°ç„¡åŠ¹ãªå‚ç…§ã¨ãªã‚‹ã®ã§ NG ã ã€‚

ãªã®ã§å‚ç…§ã™ã‚‹å´ r ã‚ˆã‚Š x ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’é•·ãã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚

```rust
{
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &x;           // --+-- 'a  |
                              //   |       |
        println!("r: {}", r); //   |       |
                              // --+       |
    }                         // ----------+
```

### é‰„å‰‡ï¼’: ãã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã€å€Ÿç”¨ãŒç”Ÿãæ®‹ã£ã¦ã„ã‚‹ã‚‚ã®ã«å¯¾ã—ã¦å¯å¤‰å‚ç…§ã¯ä½œã‚Œãªã„

ã“ã®åŸå‰‡ã¯ã‚³ãƒ¼ãƒ‰ã§æ›¸ãã¨ã€

```rust
fn main() {
    let mut data = 42;
    let immutable_ref = &data;
    let mutable_ref = &mut data; // ã‚¨ãƒ©ãƒ¼: å€Ÿç”¨ãŒç”Ÿãã¦ã„ã‚‹é–“ã¯å¯å¤‰å‚ç…§ã‚’ä½œã‚Œãªã„
    dbg!(immutable_ref);
}
```

(ChatGPT ã§ä½œæˆ)

ãŒã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã“ã¨ã‚’æŒ‡ã™ã€‚ã‚‚ã—ã“ã‚Œã‚’ã‚¨ãƒ©ãƒ¼ã«ã—ãªã‘ã‚Œã°ã€ã¾ã•ã—ããƒ‡ãƒ¼ã‚¿ç«¶åˆã‚’å¼•ãèµ·ã“ã›ã¦ã—ã¾ã†ã€‚ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ãŸã³ã«ã€CPU ã®çŠ¶æ…‹ã«ã‚ˆã£ã¦å€¤ãŒå¤‰ã‚ã£ã¦ã—ã¾ã†ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ãŒå‡ºæ¥ä¸ŠãŒã‚‹ã€‚ãªã®ã§ä»–ã®ä¸»ä½“ãŒãƒ‡ãƒ¼ã‚¿ã‚’å‚ç…§ã—ã¦ã„ã‚‹é–“ã¯ã€ãã®ãƒ‡ãƒ¼ã‚¿ã¯æ›¸ãæ›ãˆã¦ã¯ã„ã‘ãªã„ã®ã§ã‚ã‚‹ã€‚ã“ã‚ŒãŒç¦ã˜ã‚‰ã‚Œã‚‹å¬‰ã—ã•ã¯ DB ã®ãƒ­ãƒƒã‚¯ã‚’æƒ³åƒã™ã‚‹ã¨ã‚¤ãƒ¡ãƒ¼ã‚¸ãŒå‡ºã‚‹ã ã‚ã†ã€‚
ãªã®ã§ã“ã‚Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«ã¯

```rust
fn main() {
  let mut data = 42;
{
    let immutable_ref = &data;
    dbg!(immutable_ref);
}

let mutable_ref = &mut data;
*mutable_ref += 1;
dbg!(mutable_ref);
}
```

(ChatGPT ã§ä½œæˆ)

ã®ã‚ˆã†ã«ã—ã¦å€Ÿç”¨ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’åˆ‡ã£ã¦ã‹ã‚‰å¯å¤‰å‚ç…§ã‚’ä½œã‚‹ã¨è‰¯ã„ã€‚

### ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒå¬‰ã—ããªã‚‹ã®ã¯ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ç’°å¢ƒ

ã¨ã€ã“ã“ã¾ã§ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã«ã¤ã„ã¦æ›¸ã„ãŸãŒã€ç§ã¯æ™®é€šã«ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã™ã‚‹ä¸Šã§ã¯ã‚ã¾ã‚Šæ°—ã«ã—ãªãã¦ã„ã„ã¨æ€ã£ã¦ã„ã‚‹ã€‚çµŒé¨“ä¸Šã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ å‘¨ã‚Šã§å›°ã‚‹æ™‚ã¯

- ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ç’°å¢ƒ
- ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼

ã ã¨æ€ã£ã¦ã„ã‚‹ã€‚å¤šãã®å ´åˆã€å¤‰æ•°ã®ç”Ÿå­˜ç¯„å›²ã¯ç›®è¦–ã§ãã¦ã—ã¾ã†ã®ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã‚‚ã™ãã«ä¿®æ­£ã§ãã‚‹ã¨æ€ã†ã€‚Rust ã§æ‰€æœ‰æ¨©ãŒé›£ã—ã„ã¨ã„ã†è©±ã¯ãã“ã‹ã—ã“ã§èããŒã€è‡ªåˆ†ã¯ã‚ã¾ã‚Šãã†ã¯æ€ã£ã¦ã„ãªã„ã€‚ç¢ºã‹ã«æ¯æ—¥çµ¶å¯¾ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’å¼•ãèµ·ã“ã—ã¦ã„ã‚‹ãŒã€ãªã‚“ã ã‹ã‚“ã ç›´ã›ã‚‹ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã¯æ¯æ—¥å‡ºã‚‹ã‘ã©ã€‚ç›®è¦–ã§ããªã„ãƒ•ãƒ­ãƒ¼ã«ã ã‘æ³¨æ„ã™ã‚Œã°ã„ã„ã¨æ€ã£ã¦ã„ã‚‹ã€‚ãã®ä¾‹ã¨ã—ã¦ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä½¿ã†ã‚³ãƒ¼ãƒ‰ã‚’ç´¹ä»‹ã—ã¦çµ‚ã‚ã‚ã†ã€‚

## èª¬æ˜ã®ãŸã‚ã«ä¸€æ—¦ Rust ã®å¾©ç¿’

æ¬¡ã«æ‰€æœ‰æ¨©ã¨ RAII ãŒå¬‰ã—ããªã‚‹å ´é¢ã¨ã—ã¦ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ç’°å¢ƒã§ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ç´¹ä»‹ã™ã‚‹ãŒã€ãã®å‰ã«å¿…è¦ã¨ãªã‚‹å‰æçŸ¥è­˜ã«ã¤ã„ã¦æ›¸ãã€‚ã“ã‚Œã‚‰ã®æ¦‚å¿µã¯ TRPL ã«æ›¸ã‹ã‚Œã¦ã„ã‚‹ã®ã§è¦‹è¦šãˆã‚‚ã‚ã‚‹ã ã‚ã†ã€‚çŸ¥ã£ã¦ã„ãŸã‚‰ã‚¹ãƒ«ãƒ¼ã—ã¦å¤§ä¸ˆå¤«ã ã€‚

### ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿

ã¾ãš Arc ã‚„ Box ã«ä»£è¡¨ã•ã‚Œã‚‹ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã«ã¤ã„ã¦èª¬æ˜ã™ã‚‹ã€‚Wikipedia ã®å®šç¾©ã«ã¯

> In computer science, a smart pointer is an abstract data type that simulates a pointer while providing added features, such as automatic memory management or bounds checking. Such features are intended to reduce bugs caused by the misuse of pointers, while retaining efficiency. Smart pointers typically keep track of the memory they point to, and may also be used to manage other resources, such as network connections and file handles. Smart pointers were first popularized in the programming language C++ during the first half of the 1990s as rebuttal to criticisms of C++'s lack of automatic garbage collection.

ã¨ã‚ã‚‹ã€‚è¦ã™ã‚‹ã«ä¾¿åˆ©ãªæ©Ÿèƒ½ã‚’æŒã£ãŸãƒã‚¤ãƒ³ã‚¿ã®ã“ã¨ã§å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ãªã©ã®ãƒ¡ãƒ¢ãƒªç®¡ç†ã‚’æä¾›ã™ã‚‹ã€‚

#### deref

Rust ã§ã¯ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã¯ deref ã‚’å®Ÿè£…ã™ã‚‹ã®ãŒä¸€èˆ¬çš„ã ã€‚ãƒã‚¤ãƒ³ã‚¿ãªã®ã§ãã®æŒ‡ã—ç¤ºã™å…ˆã«å€¤ã¯ã‚ã‚Šã€ãã®å€¤ã‚’å–ã‚Šå‡ºã™ãŸã‚ã®æ©Ÿèƒ½ã ã€‚

```rust
pub trait Deref {
    type Target: ?Sized;

    // Required method
    fn deref(&self) -> &Self::Target;
}
```

FYI: https://doc.rust-lang.org/std/ops/trait.Deref.html

ã©ã‚Œãã‚‰ã„ä¸€èˆ¬çš„ã‹ã¨ã„ã†ã¨ã€Deref ã¯ã“ã‚Œã‚‰ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã€‚

![deref](./deref.png)

<https://doc.rust-lang.org/std/ops/trait.Deref.html#implementors>

#### ä¾‹: Box

ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã®ä¾‹ã¨ã—ã¦ Box ã‚’ç´¹ä»‹ã™ã‚‹ã€‚
å…¬å¼ã«ã¯ â€œA pointer type that uniquely owns a heap allocation of type T.â€ ã¨ã‚ã‚‹ã€‚

<https://doc.rust-lang.org/std/boxed/struct.Box.html>

æ™®é€šãªã‚‰ã‚¹ã‚¿ãƒƒã‚¯ã«ç½®ã‹ã‚Œã‚‹å€¤ã‚’ãƒ’ãƒ¼ãƒ—ã«ãŠã‘ã‚‹æ©Ÿèƒ½ã¨è¨€ãˆã‚‹ã€‚Box ã«å…¥ã‚Œã‚‹ã“ã¨ã§ RAII ã‚’åŠ¹ã‹ã›ã‚‰ã‚Œã‚‹ã¨ã‚‚ã„ãˆã€ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã®ãƒ¡ãƒ¢ãƒªç®¡ç†ã‚’å®Ÿç¾ã™ã‚‹ã¨ã„ã†å½¹å‰²ã‚’å…¨ã†ã—ã¦ã„ã‚‹ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã¨ã‚‚è¨€ãˆã‚‹ã€‚ã‚ã¨ã¯ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãªã©ã‚’å›²ã£ã¦ã€ã‚µã‚¤ã‚ºä¸å®šãªã‚‚ã®ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®ãŠã¾ã˜ãªã„ã¨ã—ã¦ã‚‚ã‚ˆãä½¿ã‚ã‚Œã‚‹ã€‚ãƒ’ãƒ¼ãƒ—ã«ç½®ãã¨ã„ã†ã®ã¯ãã†ã„ã†å¬‰ã—ã•ã‚‚ã‚ã‚‹ã€‚ã¾ã‚ Box ã‚’ä½¿ã‚ãªã„è§£æ±ºç­–ã‚‚ã‚ã‚‹ã®ã ãŒã€ãã‚Œã«ã¤ã„ã¦ã¯ <https://blog.ojisan.io/rust-dispatch/#dyn-trait-ã¨-impl-trait> ã‚’è¦‹ã¦æ¬²ã—ã„ã€‚

### ãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆ

Rust ã®ãƒˆãƒ¬ã‚¤ãƒˆã«ãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆã¨ã„ã†ã®ãŒã‚ã‚‹ã€‚

<https://doc.rust-lang.org/core/marker/index.html>

â€œPrimitive traits and types representing basic properties of types.â€ ã¨ã‚ã‚‹ãŒä½•ã®ã“ã¨ã‹ã•ã£ã±ã‚Šã ã€‚ChatGPT ã«å•ã„åˆã‚ã›ãŸã‚‰

> ãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆï¼ˆMarker Traitï¼‰ã¨ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªï¼ˆç‰¹ã« Rust ãªã©ã®ãƒˆãƒ¬ã‚¤ãƒˆã‚·ã‚¹ãƒ†ãƒ ã‚’æŒã¤è¨€èªï¼‰ã«ãŠã„ã¦ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚„é–¢æ•°ã‚’æŒãŸãªã„ã€å‹ã«ç‰¹å®šã®æ€§è³ªã‚„æŒ¯ã‚‹èˆã„ã‚’ç¤ºã™ç›®å°ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹ãƒˆãƒ¬ã‚¤ãƒˆã§ã™ã€‚ãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«å‹ã«é–¢ã™ã‚‹è¿½åŠ æƒ…å ±ã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å‹ã®åˆ¶ç´„ã‚’å¼·åˆ¶ã—ãŸã‚Šã€ç‰¹å®šã®æ©Ÿèƒ½ã‚’åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã‚‰ã—ã„ã€‚ã“ã‚Œã¯ã®ã¡ã«ç´¹ä»‹ã™ã‚‹ Send, Sync ãŒã“ã®ãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆã«å½“ã¦ã¯ã¾ã‚‹ã®ã§é ­ã®ç‰‡éš…ã«å…¥ã‚Œã¦ãŠã„ã¦æ¬²ã—ã„ã€‚

### ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰

æ™®é€šã«ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ãã‚Œã¯ CPU ã§å®Ÿè¡Œã•ã‚Œã‚‹ã€‚ã“ã®ã¨ãç„¡é™ãƒ«ãƒ¼ãƒ—ãªã©ã‚’æ›¸ãã¨ã‚³ãƒ¼ãƒ‰ã¯ãã“ã§æ­¢ã¾ã‚‹ã€‚ã—ã‹ã— CPU ã¯è¤‡æ•°ã‚³ã‚¢ãŒã‚ã£ãŸã‚Šã€é™ã‚‰ã‚ŒãŸã‚³ã‚¢æ•°ã§è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’åˆ‡ã‚Šæ›¿ãˆã¦å®Ÿè¡Œã•ã›ã‚‹ã“ã¨ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’åŒæ™‚ã«è¤‡æ•°å®Ÿè¡Œã•ã›ã‚‹ã‚ˆã†ã«è¦‹ã›ã‹ã‘ã‚‹ä»•çµ„ã¿ãŒã‚ã‚‹ã€‚è©³ã—ãã¯ [Web ã‚µãƒ¼ãƒãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£é€²åŒ–è«– 2023](https://blog.ojisan.io/server-architecture-2023/) ã«æ›¸ãæ•£ã‚‰ã—ã¦ã„ã‚‹ã®ã§è¦‹ã¦æ¬²ã—ã„ã€‚ãã†ã„ã†ä»•çµ„ã¿ãŒã‚ã‚Œã°ã€ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’æ›¸ã„ã¦ã‚‚åˆ¥ã®å‡¦ç†ã‚’ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ãã‚Œã‚’ Rust ã§ã™ã‚‹ã«ã¯ thread::spawn ã‚’ä½¿ã†ã€‚åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç«‹ã¦ã‚‹ã®ã§ã‚ã‚‹ã€‚

```rust
use std::thread;

fn main() {
    let mut handles = vec![];
    let h1 = thread::spawn(move || loop {
        print!("1")
    });
    handles.push(h1);

    let h2 = thread::spawn(move || loop {
        print!("2")
    });
    handles.push(h2);

    for handle in handles {
        handle.join().unwrap();
    }
}
```

```
> cargo run
1111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222211111111111111111111111111111111111111111111111
```

ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯è¤‡æ•°ã‚¹ãƒ¬ãƒƒãƒ‰ã§å‡¦ç†ã‚’åˆ†æ•£ã•ã›ã‚‰ã‚Œã‚‹ã®ã§ã€ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆã‚’å‘ä¸Šã§ãã‚‹ã€‚ãŸã ã—åŒæ™‚ã«å¤‰æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã™ã‚‹ã¨ãƒ¬ãƒ¼ã‚¹ã‚³ãƒ³ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã«ãªã‚‹ã®ã§ãƒ­ãƒƒã‚¯ã®ã‚ˆã†ãªä»•çµ„ã¿ãŒå¿…è¦ã«ã¯ãªã‚‹ã€‚

### ãƒ­ãƒƒã‚¯

ãã®ãŸã‚ã®ãƒ­ãƒƒã‚¯ã‚‚ Rust ã¯æä¾›ã—ã¦ã„ã‚‹ã€‚ã“ã‚Œã¯ä¸¦è¡Œå‡¦ç†ã«ãŠã„ã¦ãƒ¬ãƒ¼ã‚¹ã‚³ãƒ³ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚’é˜²ããŸã‚ã®ä»•çµ„ã¿ã ã€‚ãƒ­ãƒƒã‚¯ã®å®Ÿç¾æ–¹æ³•ã¯ã„ãã¤ã‚‚ã‚ã‚Š Rust ã§ã‚‚æä¾›ã•ã‚Œã¦ã„ã‚‹ãŒã€ä¸€ç•ªä»£è¡¨çš„ãªã®ã¯ Mutex ã ã‚ã†ã€‚

<https://doc.rust-lang.org/std/sync/struct.Mutex.html>

Mutex ã«ã¤ã„ã¦ã¯è©³ã—ãå¾Œã§è¦‹ã‚‹ãŒã–ã£ã¨ã ã‘èª¬æ˜ã™ã‚‹ã¨ã€ã‚ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã«ãŠã„ã¦ã€ãã® Lock ã‚’æŒã£ã¦ã„ã‚‹äººã—ã‹ãƒªã‚½ãƒ¼ã‚¹ã‚’è§¦ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹ä»•çµ„ã¿ã ã€‚ã“ã® Lock ã‚’å–ã‚‹ãƒ»è§£æ”¾ã™ã‚‹ã¨ã„ã†ä»•çµ„ã¿ã‚’ã€ãƒ¡ãƒ¢ãƒªç®¡ç†ã¨åŒã˜ã RAII ã«ä»»ã›ã‚‹ã“ã¨ãŒ Rust ã®å¼·ã¿ã§ã‚‚ã‚ã‚‹ã€‚

## ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¨ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ 

ã•ã¦ã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒç‰¹ã«ç”Ÿãã‚‹ã®ã¯ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãªã®ã§ãã®ä¾‹ã‚’è¦‹ã¦ã„ã“ã†ã€‚ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ¬ãƒƒãƒ‰ã§è€ƒãˆã‚‹å ´åˆã€ã‚ã‚‹ç¨®ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æ„è­˜ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã™ã‚Œã°æ‰€æœ‰æ¨©å‘¨ã‚Šã§å›°ã‚‹ã“ã¨ãŒãªã„ã¯ãšã ã€‚ (å¯å¤‰å‚ç…§å‘¨ã‚Šã¯ã‚„ã‚„ã“ã—ã„ã‘ã©ã­ï¼‰

```rust
use std::thread;

struct Data(i32);

fn main() {
    let cache = Data(0);

    thread::spawn(move || {
        cache;
    });

    thread::spawn(move || {
        cache;
    });
}
```

ãã†ã™ã‚‹ã¨ã€è‰²ã€…ã¨ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹

```rust
use of moved value: `cache`
value used here after moverustcClick for full compiler diagnostic
main.rs(9, 19): value moved into closure here
main.rs(10, 9): variable moved due to use in closure
main.rs(14, 9): use occurs due to use in closure
main.rs(7, 9): move occurs because `cache` has type `Data`, which does not implement the `Copy` trait
No quick fixes available
```

ã‚³ãƒ”ãƒ¼ã—ã‚ã¨è¨€ã‚ã‚Œã¦ã„ã‚‹ã®ã§ã‚³ãƒ”ãƒ¼ã—ãŸã„ãŒã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¨ã—ã¦ä½¿ã„ãŸã„ã®ã§ãã‚“ãªã“ã¨ã¯ã§ããªã„ã€‚

### å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ã‚’ä½œã‚‹

å®Ÿæ…‹ã®ã‚³ãƒ”ãƒ¼ã¯ã§ããªã„ã®ã§å‚ç…§ã‚«ã‚¦ãƒ³ã‚¿ã‚’å¢—ã‚„ã™ã‚ˆã†ã«ã™ã‚‹

```rust
use std::{sync::Arc, thread};

#[derive(Debug)]
struct Data(i32);

fn main() {
    let cache = Arc::new(Data(0));
    let mut handles = vec![];

    {
        let cache = Arc::clone(&cache);
        let handle = thread::spawn(|| {
            cache;
        });
        handles.push(handle)
    }

    {
        let cache = Arc::clone(&cache);

        let handle = thread::spawn(|| {
            cache;
        });
        handles.push(handle)
    }

    for handle in handles {
        handle.join().unwrap();
    }

    dbg!(cache);
}
```

```bash
> cargo run
[src/main.rs:31] cache = Data(
    0,
)
```

ãã‚Œã‚’å®Ÿç¾ã™ã‚‹ã®ãŒ Arc ã ã€‚

ãŸã ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¯ä½¿ã†ã ã‘ã§ãªãæ›´æ–°ã™ã‚‹ã‚‚ã®ãªã®ã§ã€ãã‚Œã‚’å®Ÿç¾ã•ã›ãŸã„ã€‚

```rust
use std::{sync::Arc, thread};

#[derive(Debug)]
struct Data(i32);

fn main() {
    let cache = Arc::new(Data(0));
    let mut handles = vec![];

    {
        let cache = Arc::clone(&cache);
        let handle = thread::spawn(|| {
            cache.0 = cache.0 + 1;
        });
        handles.push(handle)
    }

    for handle in handles {
        handle.join().unwrap();
    }

    dbg!(cache);
}
```

ã“ã‚Œã¯

```bash
rust_mutli_life::Data
0: i32 // size = 4, align = 4, offset = 0
cannot assign to data in an `Arc`
trait `DerefMut` is required to modify through a dereference, but it is not implemented for `Arc<Data>`rustcClick for full compiler diagnostic
```

ã¨ã„ã£ãŸã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚DerefMut ã¨ã„ã†ã®ã¯ãã®ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å¯å¤‰å‚ç…§ã‚’ã¨ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ãªã„ã¨ã„ã‘ãªã„ã“ã¨ã‚’è¡¨ã™ã€‚

### DerefMut

â€œUsed for mutable dereferencing operations, like inÂ `*v = 1;`.â€ ã¨ã‚ã‚‹ã€‚

[https://doc.rust-lang.org/std/ops/trait.DerefMut.html](https://doc.rust-lang.org/std/ops/trait.DerefMut.html)

DerefMut ã‚’å®Ÿè£…ã™ã‚‹ã«ã‚ãŸã£ã¦ã¯ deref_mut ã‚’å®Ÿè£…ã™ã‚Œã°ã„ã„ã€‚

```rust
pub trait DerefMut: Deref {
    // Required method
    fn deref_mut(&mut self) -> &mut Self::Target;
}
```

ã¨ãªã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã™ã‚‹ã€‚å¯å¤‰å‚ç…§ã‚’è¿”ã™é–¢æ•°ã ã€‚Deref ã‚’ç¶™æ‰¿ã—ã¦ã„ã‚‹ã®ã§ Deref ã‚‚å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã€‚

```rust
use std::{
    ops::{Deref, DerefMut},
    sync::{Arc, Mutex},
    thread,
};

#[derive(Debug)]
struct Data<T>(T);

impl<T> Deref for Data<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<T> DerefMut for Data<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

fn main() {
    let cache = Arc::new(Data(0));
    let mut handles = vec![];
    {
        let cache = Arc::clone(&cache);

        let handle = thread::spawn(move || {
            cache.0 += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    dbg!(cache);
}
```

ã ãŒã“ã‚Œã¯

```rust
cannot assign to data in an `Arc`
trait `DerefMut` is required to modify through a dereference, but it is not implemented for `Arc<Data<i32>>`rustcClick for full compiler diagnostic
```

ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚å¹³ãŸãã¨ã„ã†ã¨ Arc ãŒ DerefMut ã‚’æŒã£ã¦ã„ãªã„ã®ã§ã€type coersion ãŒèµ·ã“ã›ãªã„ã“ã¨ã‚’æŒ‡ã—ã¦ã„ã‚‹ã€‚ã“ã‚Œã¯å½“ç„¶ã§ã€Arc ã® A ã¯ Atomic ãªè¨³ã§ã€è‡ªç”±ã«ä¸­ã‚’æ›¸ãæ›ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã¯ãªã£ã¦ã„ãªã„ã®ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã‚ã‘ã§ã€unsafe ã‚’ä½¿ã£ã¦å¯å¤‰å‚ç…§ã‚’å–ã‚Šå‡ºã™ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ã¿ã‚‹ã€‚

```rust
use std::{
    cell::UnsafeCell,
    ops::{Deref, DerefMut},
    sync::Arc,
    thread,
};

#[derive(Debug)]
struct Data<T>(UnsafeCell<T>);

impl<T> Deref for Data<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        unsafe { &*self.0.get() }
    }
}

impl<T> DerefMut for Data<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *self.0.get() }
    }
}

fn main() {
    let cache = Arc::new(Data(UnsafeCell::new(0)));
    let mut handles = vec![];
    {
        let cache = Arc::clone(&cache);
        let handle = thread::spawn(move || {
            unsafe { *cache.0.get().as_mut().unwrap() = *cache.0.get() + 1 };
        });
        handles.push(handle);
    }

    {
        let cache = Arc::clone(&cache);
        let handle = thread::spawn(move || {
            unsafe { *cache.0.get().as_mut().unwrap() = *cache.0.get() + 1 };
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    unsafe {
        let value = &*cache.0.get();
        println!("Value: {}", value);
    };
}
```

ã¨ç„¡ç†çŸ¢ç†å®Ÿè£…ã™ã‚‹ã€‚ã ãŒã€ä»Šåº¦ã¯ã“ã‚Œã¯

```rust
`UnsafeCell<i32>` cannot be shared between threads safely
within `Data<i32>`, the trait `Sync` is not implemented for `UnsafeCell<i32>`
required for `Arc<Data<i32>>` to implement `Send`
```

ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚thread::spawn ã¯

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T,
    F: Send + 'static,
    T: Send + 'static,
{
    Builder::new().spawn(f).expect("failed to spawn thread")
}
```

ã¨ãªã£ã¦ãŠã‚Šã€trait å¢ƒç•Œã« Send ã¨ Sync ã‚’å–ã‚‹ã€‚ãªã®ã§ `unsafe impl<T> Send for Data<T> {}` ã¨ `unsafe impl<T> Sync for Data<T> {}` ã§ç„¡ç†çŸ¢ç†å®Ÿè£…ã™ã‚‹ã€‚

```rust
use std::{
    cell::UnsafeCell,
    ops::{Deref, DerefMut},
    sync::Arc,
    thread,
};

#[derive(Debug)]
struct Data<T>(UnsafeCell<T>);

impl<T> Deref for Data<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        unsafe { &*self.0.get() }
    }
}

impl<T> DerefMut for Data<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut *self.0.get() }
    }
}

unsafe impl<T> Send for Data<T> {}
unsafe impl<T> Sync for Data<T> {}

fn main() {
    let cache = Arc::new(Data(UnsafeCell::new(0)));
    let mut handles = vec![];
    {
        let cache = Arc::clone(&cache);
        let handle = thread::spawn(move || {
            unsafe { *cache.0.get().as_mut().unwrap() = *cache.0.get() + 1 };
        });
        handles.push(handle);
    }

    {
        let cache = Arc::clone(&cache);
        let handle = thread::spawn(move || {
            unsafe { *cache.0.get().as_mut().unwrap() = *cache.0.get() + 1 };
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    unsafe {
        let value = &*cache.0.get();
        println!("Value: {}", value);
    };
}
```

```bash
â¯ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/rust-mutli-life`
Value: 2
```

ã¨ã€ç„¡ç†çŸ¢ç†ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’é€šã—ãŸãŒã€æ™®é€šã¯ã“ã‚“ãªã“ã¨ã¯ã—ãªã„æ–¹ãŒè‰¯ã„ã€‚ãã‚Œã«ã¯ã„ãã¤ã‹ç†ç”±ãŒã‚ã‚Šã€ãã®ç†ç”±ã®ã©ã‚Œã‚‚ ã€Œunsafe ã‚’ safe ã®ç¢ºè¨¼ãªãä½¿ã†ãªã€ã«é›†ç´„ã•ã‚Œã‚‹ã€‚Rust ã«ã¯å¹¸ã„ã«ã‚‚ã“ã†ã„ã£ãŸå®Ÿè£…ã‚’ safe ãªç¢ºè¨¼ã‚’æŒã£ã¦ä½œã£ã¦ãã‚Œã¦ã„ã‚‹æ¨™æº–æ©Ÿèƒ½ãŒã‚ã‚‹ã®ã§ãã‚Œã‚’ä½¿ãŠã†ã€‚

### Mutex ã§ Lock ã‚’å–ã‚‹

ãã‚ŒãŒ Mutex ã ã€‚

[https://doc.rust-lang.org/std/sync/struct.Mutex.html](https://doc.rust-lang.org/std/sync/struct.Mutex.html)

Mutex ã§ lock ã‚’ã¨ã‚‹ã¨ MutexGuard ãŒå¸°ã£ã¦ãã‚‹ã€‚ã“ã‚ŒãŒ DerefuMut ã‚’æŒã¤ã€‚

```rust
#[stable(feature = "rust1", since = "1.0.0")]
impl<T: ?Sized> Deref for MutexGuard<'_, T> {
    type Target = T;

    fn deref(&self) -> &T {
        unsafe { &*self.lock.data.get() }
    }
}

#[stable(feature = "rust1", since = "1.0.0")]
impl<T: ?Sized> DerefMut for MutexGuard<'_, T> {
    fn deref_mut(&mut self) -> &mut T {
        unsafe { &mut *self.lock.data.get() }
    }
}
```

ã“ã‚Œã‚’ã‚‚ã£ã¨æ·±æ˜ã‚‹ã¨ MutexGuard ã¯

```rust
pub struct MutexGuard<'a, T: ?Sized + 'a> {
    lock: &'a Mutex<T>,
    poison: poison::Guard,
}

pub struct Mutex<T: ?Sized> {
    inner: sys::MovableMutex,
    poison: poison::Flag,
    data: UnsafeCell<T>,
}

#[stable(feature = "rust1", since = "1.0.0")]
unsafe impl<T: ?Sized + Send> Send for Mutex<T> {}
#[stable(feature = "rust1", since = "1.0.0")]
unsafe impl<T: ?Sized + Send> Sync for Mutex<T> {}

#[stable(feature = "rust1", since = "1.0.0")]
    pub fn lock(&self) -> LockResult<MutexGuard<'_, T>> {
        unsafe {
            self.inner.raw_lock();
            MutexGuard::new(self)
        }
    }
```

ã¨ãªã£ã¦ã„ã‚‹ã€‚å†…éƒ¨å¯å¤‰æ€§ã‚’è¨±ã™ãŸã‚ã« UnsafeCell ã‚‚ä½¿ã£ã¦ã„ã‚‹ã€‚å…ˆã»ã©è‡ªåˆ†ãŒå®Ÿè£…ã—ãŸã‚‚ã®ã«è¿‘ã„ã€‚ã ãŒã€data ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ pub ã«ãªã£ã¦ã„ãªã„ã®ã§ lock ã‚’é€šã•ãªã„ã¨ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„å®‰å…¨è£…ç½®ãŒä»˜ã„ã¦ãŠã‚Šã€unsafe ãªãŒã‚‰ã‚‚ safe ã«ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã€‚ã¡ãªã¿ã« raw_lock ã¯ OS ã®æ’ä»–åˆ¶å¾¡å‘¨ã‚Šã®æ©Ÿèƒ½ã‚’å‘¼ã³å‡ºã—ã¦ã„ãŸã€‚

UnsafeCell ã¯ã“ã®å ´åˆã€å¿…ãšå¿…è¦ã¨ãªã‚‹ã€‚ãªãœãªã‚‰ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã§ä½¿ã†ä»¥ä¸Šã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ç‚¹ã§ã¯ã‚ã‚‹å€¤ã®æ‰€æœ‰è€…ãŒåŒæ™‚ã«è¤‡æ•°å­˜åœ¨ã™ã‚‹ã“ã¨ã‚’è¨±å®¹ã—ãŸã„ã‹ã‚‰ã ã€‚ä»£ã‚ã‚Šã« Mutex ãŒå®Ÿè¡Œæ™‚ã«åŒæ™‚æ›¸ãè¾¼ã¿ãªã©ã®ãƒ¬ãƒ¼ã‚¹ã‚³ãƒ³ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚’é˜²ã„ã§ãã‚Œã‚‹ã“ã¨ã‚’æœŸå¾…ã™ã‚‹ã€‚

```rust
use std::{
    sync::{Arc, Mutex},
    thread,
};

#[derive(Debug)]
struct Data(i32);

fn main() {
    let cache = Arc::new(Mutex::new(Data(0)));
    let mut handles = vec![];
    {
        let cache = Arc::clone(&cache);

        let handle = thread::spawn(move || {
            let mut guard = cache.lock().unwrap();
            guard.0 = guard.0 + 1;
        });
        handles.push(handle);
    }

    {
        let cache = Arc::clone(&cache);

        let handle = thread::spawn(move || {
            let mut guard = cache.lock().unwrap();
            guard.0 = guard.0 + 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    dbg!(cache);
}
```

### thread::spawn ã«ã¯å¤‰æ•°ã‚’ãã®ã¾ã¾ move ã§ããªã„

ã“ã“ã§ã¯ Mutex ã‚’ä½¿ã£ãŸä»¥å¤–ã«ã‚‚ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã« move ã‚’ä»˜ã‘ã¦ã„ã‚‹ã€‚

```rust
use std::{
    sync::{Arc, Mutex},
    thread,
};

#[derive(Debug)]
struct Data(i32);

fn main() {
    let cache = Arc::new(Mutex::new(Data(0)));
    let mut handles = vec![];
    {
        let cache = Arc::clone(&cache);

        let handle = thread::spawn(move || {
            let mut guard = cache.lock().unwrap();
            guard.0 = guard.0 + 1;
        });
        handles.push(handle);
    }

    {
        let cache = Arc::clone(&cache);

        let handle = thread::spawn(move || {
            let mut guard = cache.lock().unwrap();
            guard.0 = guard.0 + 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    dbg!(cache);
}
```

ã“ã‚Œã‚’ã‚µãƒœã£ã¦

```rust
    {
        let cache = Arc::clone(&cache);

        let handle = thread::spawn(|| {
            let mut guard = cache.lock().unwrap();
            guard.0 = guard.0 + 1;
        });
        handles.push(handle);
    }
```

ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã¨ã€

```bash
{closure#6} // size = 8, align = 8
impl Fn()
Captures
cache by immutable borrow
to force the closure to take ownership of `cache` (and any other referenced variables), use the `move` keyword: `move `rustcE0373
main.rs(15, 36): original diagnostic
closure may outlive the current function, but it borrows `cache`, which is owned by the current function
may outlive borrowed value `cache`rustcClick for full compiler diagnostic
```

ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚ä¸€è¨€ã§è¨€ã†ã¨ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã™ã‚‹å‡¦ç†ãŒå‘¼ã³å‡ºã—å…ƒã‚ˆã‚Šæ—©ãçµ‚ã‚ã‚‹ä¿è¨¼ãŒãªã„ãŸã‚ã«ã€ç„¡åŠ¹ãªå‚ç…§ãŒç”Ÿã¾ã‚Œã‚‹å¯èƒ½æ€§ã‚’æ½°ã—ãŸã„ã‹ã‚‰ move ã‚’ã¤ã‘ã‚ã¨è¨€ã†ã“ã¨ãªã®ã ãŒã€è©³ã—ãè¦‹ã¦ã„ã“ã†ã€‚

ã¾ãš spawn ã¯

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T,
    F: Send + 'static,
    T: Send + 'static,
{
    Builder::new().spawn(f).expect("failed to spawn thread")
}
```

ã‚’è¦æ±‚ã—ãŸã®ã§ã‚ã£ãŸã€‚ã“ã® FnOnce ãŒã‚­ãƒ¢ã¨ãªã‚Šã€ã“ã‚Œã¯ move ã‚’è¦æ±‚ã™ã‚‹ã€‚

FYI: [https://qiita.com/hiratasa/items/c1735dc4c7c78b0b55e9](https://qiita.com/hiratasa/items/c1735dc4c7c78b0b55e9)

ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã«ã¯ FnOnce ä»¥å¤–ã«ã‚‚ Fn, FnMut ãŒã‚ã‚‹ãŒã€move ã‚’è¦æ±‚ã™ã‚‹ã‹ã©ã†ã‹ã¯ãã‚Œã‚‰ trait ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’è¦‹ã‚‹ã¨ã‚ã‹ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚

```rust

pub trait Fn<Args>: FnMut<Args> {
    /// Performs the call operation.
    #[unstable(feature = "fn_traits", issue = "29625")]
    extern "rust-call" fn call(&self, args: Args) -> Self::Output;
}

pub trait FnMut<Args>: FnOnce<Args> {
    /// Performs the call operation.
    #[unstable(feature = "fn_traits", issue = "29625")]
    extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output;
}

pub trait FnOnce<Args> {
    /// The returned type after the call operator is used.
    #[lang = "fn_once_output"]
    #[stable(feature = "fn_once_output", since = "1.12.0")]
    type Output;

    /// Performs the call operation.
    #[unstable(feature = "fn_traits", issue = "29625")]
    extern "rust-call" fn call_once(self, args: Args) -> Self::Output;
}
```

Fn ã¯ &self, FnMut ã¯ &mut self ã‚’å–ã‚‹ã«å¯¾ã—ã€FnOnce ã¯ self ãã®ã‚‚ã®ã‚’å¼•æ•°ã«å–ã‚Šã€æ‰€æœ‰æ¨©ã‚’å¥ªã†ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã‚‹ã€‚ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã¯ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ãŸå¤‰æ•°ã¯åŒ¿åã®æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§æŒã¤ã¨è€ƒãˆã‚‰ã‚Œã€ã©ã®å¤‰æ•°ã‚’ã©ã†ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ãŸã‹ã«ã‚ˆã£ã¦ã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã®æ§‹é€ ä½“ãŒã©ã® trait ã‚’å®Ÿè£…ã™ã‚‹ã‹ãŒæ±ºã¾ã‚‹ã€‚

ä¾‹ãˆã° Fn ã‚’å®Ÿè£…ã—ãŸã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã®ä¸­ã§ data ã¨ã„ã†å¤‰æ•°ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ãªã‚‰ã°ã€

```rust
struct Closure {
  data: &T
}
```

ã¨ã„ã†å‹ã«ãªã‚‹ã—ã€ FnOnce ã‚’å®Ÿè£…ã—ãŸã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã§ã‚ã‚Œã°

```rust
struct Closure {
  data: T
}
```

ãŒä½œã‚‰ã‚Œã‚‹ã€‚ä»Šå› spawn ã¯ FnOnce ã‚’å®Ÿè£…ã—ãŸã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’è¦æ±‚ã—ã¦ã„ã‚‹ã®ã§ã€å€Ÿç”¨ã§ã¯ãªãã€æ‰€æœ‰æ¨©ã”ã¨æ¸¡ã™å¿…è¦ãŒç”Ÿã¾ã‚Œã¦ã„ã‚‹ã€‚ãã®ãŸã‚ã« move ãŒå¿…è¦ã¨ãªã‚‹ã€‚

ã“ã“ã§ move ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«ã¤ã„ã¦è¦‹ã¦ã¿ã‚ˆã†ã€‚

FYI: [https://doc.rust-lang.org/std/keyword.move.html](https://doc.rust-lang.org/std/keyword.move.html)

> Capture aÂ [closure](https://doc.rust-lang.org/book/ch13-01-closures.html)â€™s environment by value.
>
> `move`Â converts any variables captured by reference or mutable reference to variables captured by value.

```rust
let data = vec![1, 2, 3];
let closure = move || println!("captured {data:?} by value");

// data is no longer available, it is owned by the closure
```

ã¨ã‚ã‚‹ã€‚

æ‰€æœ‰æ¨©ã‚’ç§»ã™ãŸã‚ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ã€‚

### Rc vs Arc

ã„ã¾ Arc ã¨ã„ã†ã®ã‚’ä½¿ã£ãŸãŒä¼¼ãŸã‚‚ã®ã« Rc ã¨ã„ã†ã®ãŒã‚ã‚‹ã€‚

FYI: [https://doc.rust-lang.org/std/rc/struct.Rc.html](https://doc.rust-lang.org/std/rc/struct.Rc.html)

> A single-threaded reference-counting pointer. â€˜Rcâ€™ stands for â€˜Reference Countedâ€™.

ã¨ã‚ã‚‹ã€‚

æ™®é€šã¯ä¸€ã¤ã®å€¤ã«å¯¾ã—ã¦æ‰€æœ‰æ¨©ã‚’æŒã¤ã®ã¯ä¸€ã¤ã®å¤‰æ•°ã ãŒã€Rc ã‚’ä½¿ã†ã“ã¨ã§ã“ã®åˆ¶ç´„ã‚’å–ã£æ‰•ãˆã‚‹ã€‚ä¾‹ãˆã°ã‚°ãƒ©ãƒ•æ§‹é€ ã¯ã€ãƒãƒ¼ãƒ‰ã«å¯¾ã—ã¦è¤‡æ•°ã®ã‚¨ãƒƒã‚¸ãŒç´ã¥ãã®ã§ã€ã“ã†ã„ã£ãŸè¤‡æ•°ã®æ‰€æœ‰æ¨©ã‚’æŒã¦ã‚‹ä»•çµ„ã¿ãŒå¿…è¦ã¨ãªã‚‹ã€‚

ãŸã ã— Rc ã¯ ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã¯ãªã„ã®ã§ thread::spawn ã®ä¸­ã§ä½¿ã†ã“ã¨ãŒã§ããªã„ã€‚

```rust
use std::{rc::Rc, sync::Mutex, thread};

#[derive(Debug)]
struct Data(i32);

fn main() {
    let cache = Rc::new(Mutex::new(Data(0)));
    let mut handles = vec![];
    {
        let cache = Rc::clone(&cache);

        let handle = thread::spawn(move || {
            let mut guard = cache.lock().unwrap();
            guard.0 = guard.0 + 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    dbg!(cache);
}
```

```bash
`Rc<Mutex<Data>>` cannot be sent between threads safely
within `[closure@src/main.rs:12:36: 12:43]`, the trait `Send` is not implemented for `Rc<Mutex<Data>>`rustcClick for full compiler diagnostic
main.rs(12, 36): within this `[closure@src/main.rs:12:36: 12:43]`
main.rs(12, 22): required by a bound introduced by this call
main.rs(12, 36): required because it's used within this closure
mod.rs(662, 8): required by a bound in `spawn`
No quick fixes available
```

ã§ã¯ Arc ãŒä¸Šä½äº’æ›ã«ã‚‚æ€ãˆã‚‹ãŒã€Rc ã¯ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã®åˆ©ç”¨ã‚’è€ƒãˆã‚‹ã®ã§ã€Arc ã¨æ¯”è¼ƒã—ã¦åŒæœŸã‚„ãƒ­ãƒƒã‚¯ã‚’è€ƒãˆã‚‹å¿…è¦ãªã„ã€‚ãã®ãŸã‚ Rc ã®æ–¹ãŒã‚³ã‚¹ãƒˆãŒä½ã„ã€‚

ã•ã¦ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ãªã„ã“ã¨ã®åˆ¤å®šã«ã¤ã„ã¦ã‚‚è§£èª¬ãŒå¿…è¦ã ã‚ã†ã€‚ã“ã‚Œã¯ç«¯çš„ã«ã„ã†ã¨ Rc<Mutex<Data>> ã« Send ãŒå®Ÿè£…ã•ã‚Œã¦ã„ãªãã¦ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ãªã„ã¨è¨€ã‚ã‚Œã¦ã„ã‚‹ã€‚

ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©çš„ã«ã¯ã€spawn ã®ãƒˆãƒ¬ã‚¤ãƒˆå¢ƒç•ŒãŒ

```rust
#[stable(feature = "rust1", since = "1.0.0")]
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T,
    F: Send + 'static,
    T: Send + 'static,
{
    Builder::new().spawn(f).expect("failed to spawn thread")
}
```

Send ã‚’è¦æ±‚ã—ã¦ã„ã‚‹ãŸã‚ã€Send ãŒãªã„ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã‚‰ãªã„ã¨ã„ã£ã¦ã„ã‚‹ã€‚

## ãƒãƒ¼ã‚«ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆ Send + Sync

Send ã¯ [https://doc.rust-lang.org/std/marker/trait.Send.html](https://doc.rust-lang.org/std/marker/trait.Send.html) ã§ã€

Types that can be transferred across thread boundaries.

ã§ã‚ã‚‹ã€‚ã¤ã¾ã‚Š thread ã‚’è·¨ã„ã§ä½¿ãˆã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã€‚

Sync ã¯ [https://doc.rust-lang.org/std/sync/](https://doc.rust-lang.org/std/sync/) ã§ã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯ã§ãã‚‹ã€‚

ã“ã‚Œã‚‰ã¯ã‚ˆãã€Œ`&T`(`T`ã¸ã®å‚ç…§)ãŒ`Send`ãªã‚‰ã€å‹`T`ã¯`Sync` ã€ã¨è¡¨ç¾ã•ã‚Œã‚‹ã€‚

[https://doc.rust-jp.rs/book-ja/ch16-04-extensible-concurrency-sync-and-send.html](https://doc.rust-jp.rs/book-ja/ch16-04-extensible-concurrency-sync-and-send.html)

Mutex ã‚’ä½¿ã‚ãšã«ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã‚’å®Ÿè¡Œã—ãŸéš›ã€

```rust
unsafe impl<T> Send for Data<T> {}
unsafe impl<T> Sync for Data<T> {}
```

ã¨ã„ã†ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ãŸã€‚

ã“ã‚Œã¯ unsafe ã‚’ã¤ã‘ãªã‘ã‚Œã°

```rust
the trait `Send` requires an `unsafe impl` declarationrustcClick for full compiler diagnostic
No quick fixes available
```

ã¨è¨€ã‚ã‚Œã‚‹ã€‚

```rust
pub unsafe auto trait Send {
    // empty.
}
```

ã¨ãªã£ã¦ã„ã‚‹ãŸã‚ã ã€‚Send ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ãŒã€Send è‡ªä½“ãŒã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã‹ã©ã†ã‹ã¯ã€é–‹ç™ºè€…ãŒãƒ­ãƒƒã‚¯ãªã‚Šã®ä»•çµ„ã¿ã§ä¿è¨¼ã™ã‚‹ã—ã‹ãªãã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯åˆ†ã‹ã‚‰ãªã„ã€‚ãŸã ãã‚“ãªã“ã¨ã¯é–‹ç™ºè€…ãŒæ¯å›ã—ãªãã¦ã‚‚ã„ã„ã‚ˆã†ã«ãã†ã„ã£ãŸãƒã‚§ãƒƒã‚¯ã¯ Rust ã®è¨€èªæ©Ÿèƒ½ãŒã™ã§ã«çµ„ã¿è¾¼ã‚“ã§ãã‚Œã¦ã„ã‚‹ã—ã€Mutex ã®ã‚ˆã†ãªæ™®æ®µä½¿ã†ã‚ˆã†ãªã‚‚ã®ã«å¯¾ã—ã¦ã¯ Send ã® unsafe impl ãŒæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå´ã§ã™ã§ã«ã•ã‚Œã¦ã„ã‚‹ã€‚Send è‡ªä½“ã‚’å®Ÿè£…ã—ã‚ˆã†ã¨ã™ã‚‹ã®ã¯ unsafe ã ãŒã€åƒ•ãŸã¡åˆ©ç”¨è€…ã¯æ°—ã«ã›ãšã«ä½¿ãˆã‚‹ã®ã§æ°—ã«ã—ãªãã¦è‰¯ã„ã€‚

## è¾›ã„æ™‚ã¯ã‚³ãƒ”ãƒ¼ã—ãŸã‚Šã‚¯ãƒ­ãƒ¼ãƒ³ã—ãŸã‚Šã—ãŸã‚‰è§£æ±ºã™ã‚‹ã‚ˆ

ã§ã€ã“ã“ã¾ã§ãã©ãã©æ›¸ã„ãŸãŒã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚„æ‰€æœ‰æ¨©ã‚’é©åˆ‡ã«ä½¿ã†ã®ã¯é›£ã—ãã¦ã€æ‰±ã„ã‚‚ã‚ã‚“ã©ãã•ã„ã¨æ€ã†ã€‚ãªã®ã§ã‚ˆãè‡ªåˆ†ã¯ã©ã†ã«ã‚‚è§£æ±ºã§ããªã‹ã£ãŸã‚‰ã‚¯ãƒ­ãƒ¼ãƒ³ã—ãŸã‚Šã‚³ãƒ”ãƒ¼ã—ã¦ã„ã‚‹ã€‚ã‚‚ã¡ã‚ã‚“ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ‰±ã†ãªã©å‚ç…§ãŒæœ¬è³ªã§ã‚ã‚‹å ´åˆã¯ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¤ã‘ã¦é ‘å¼µã‚‹ãŒã€åˆ¥ã«ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä»¥å¤–ãŒæ°—ã«ãªã‚‰ãªã„å ´é¢ã ã¨ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦ã„ã‚‹ã€‚åˆ¥ã«è‡ªåˆ†ã®å•é¡Œå¯¾è±¡ã¯ãã‚“ãªã‚·ãƒ“ã‚¢ãªä¸–ç•Œã§ã¯ãªã„ã®ã§ã“ã‚Œã§å•é¡Œãªã„ã€‚IO ã®ã‚³ã‚¹ãƒˆã«æ¯”ã¹ãŸã‚‰å¤§æŠµã®ã‚³ã‚¹ãƒˆã¯å®‰ã„ã—ã€ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¾ãã£ã¦ã‚‚ RAII ãŒã„ã„æ„Ÿã˜ã«ã—ã¦ãã‚Œã‚‹ã¨æ€ã£ã¦ã„ã‚‹ã€‚

ã¨ã‹æ›¸ã„ã¦ã„ã‚‹ã¨ Rust æ›¸ã‘ã‚‹è·å ´ã‹ã‚‰å£°ãŒã‹ã‹ã‚‰ãªã•ãã†ãªã®ã§ã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®å‹‰å¼·ã‚’é ‘å¼µã‚ŠãŸã„ã€‚

ï¾ï¾—ï½¯ï¾ï¾—ï½¯ ğŸ‘€
