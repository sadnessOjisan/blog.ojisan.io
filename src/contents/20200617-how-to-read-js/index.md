---
path: /how-to-read-js
created: "2020-06-17"
title: JSのライブラリを読むときに知っておくといいこと
visual: "./visual.png"
---

ライブラリを読むっていうトレーニングをやりはじめたのですが、
あまりやったことがなかったのですが、続けているうちにだんだん読み方がわかってきたのでまとめました。

個人的に苦労した点は

- code jump が効かない
  - オブジェクトの破壊がある
  - TS で書かれていない
- あ

読み方 TIPS というよりは「こういう読み方したら俺はよかった」みたいな感じの内容ですので、もし「もっといい読み方があるよ」みたいなのがありましたら[Issue](https://github.com/sadnessOjisan/blog.ojisan.io/issues)などで教えていただけると嬉しいです。

ブラウザの話と NodeJS の話があると思うのですが、全部コンソール or ターミナルに出力しているので、私に取っては読み方としては同じです。

## 読む準備

適宜、改造したコードなどの差分を確認するためにリモートで PR を作って読んでいます。
その準備をします。

### 読む目的を考える

何を今更という感じの内容ですが、大事だと思っています。
特に全体感を掴みたいのか、具体的に詰まってる処理があってその挙動を知りたいのかで変わってきます。
ここでは全体感を掴むための読み方がメインになっています。
なぜなら、具体的に詰まってる処理があってその挙動を知りたいと思ってコード検索かけてもその呼ばれ方とかを調べていくと、結局全体感を知らないと問題を解決できないからです。

### orgnization に fork する

clone ではなく fork しています。
また最近は読解のために orgnization も作っており、そこにため込むようにしています。
そうすることで、自分のレポジトリがライブラリだらけになるということを防いでいます。
もちろん、リモートに push しないなら clone でもいいと思います。
しかし後述するように、適宜差分を取ってそれを GUI で手軽にみたいといった気持ちがあるので、リモートに push しています。

### format する

Editor の設定で自動 format しているので、save したときに format が効いて差分がたくさん出るということを防ぐために、手元に持ってきた時点で一度 format しています。

```sh
$ npx src --write 'src/**/*.{js,ts,jsx,tsx}'
```

で一気に format かけています。

最近のライブラリは prettier のようなものがされていますが、読みたいと思うようなライブラリは大体歴史の長いものなので、そういったものが入ってなかったりします。
そのため先に format を入れることで差分を防ぐことができます。

### 自分の branch に PR を作る

format したら自分の branch に push し、**自分に**PR を出しておきます。
間違えて origin にやってはいけません。
私はそれに気づかずに、`// この実装は多分よくない` みたいなメモ書きを入れたものを作者に送ってしまった過去があります。

## 使われ方から読む

私はライブラリを読んだだけでは動きを想像できないので、小さく動かす環境を作ったりもしています。

### examples を読む

ライブラリによっては examples がついている場合があります。
もしあるならその動かし方が README に書いてあるはずなので、それを動かしながら print debug などをします。

### 簡単に手元で動かすサンプルを作る

もし example がない場合は手元で動かしましょう。
なるべく最小構成を作って動かしてください。
これはどのレポジトリでやってもいいとは思いますが、私はそういった sandbox として好き放題やるようの organization を作って、そこに push していっています。

## メイン関数を探す

logger を入れるとしてもどこに入れるかを探るためにコードを読んでいきます。
library が呼ばれる入り口から辿っていくと、気になるところまでたどり着けるので、そのようにして読んでいきます。

### pakage.json

ライブラリのエントリポイントは package.json の index に書かれています。

### bin

CLI などは bin が実行されています。

## 読み進める

### code jump

code jump できるエディタを使ってください。
VSCode など lsp-client を持つエディタを選びます。
lsp-client は後述するドキュメンテーションのためにも役立ちます。

### print debug

#### console.dir

オブジェクトの中を見ます。

#### JSON.stringify()

これもオブジェクトの中を見ます。
オブジェクトが深くないとわかっているときに使っています。

#### debugger は？

私は debugger の使い方を覚えれないという背景があり、print debug を使っています。
コードを小さく実行して読んでるので今のところは困っていませんが、大規模になるとあった方が良いのかもしれません。
（**他の人がどうやってるのか気になっている**）

### docs

わかった処理は documentation 文字列で処理を書くようにしています。

### テストを読む

挙動がわからないときはテストも読みます。
テストには入力と期待する動作が書かれているのでその処理の概略は掴めます。

ただ大きい処理だといわゆる in と out がしっかりしている unit テストではなく、mock した値の中をたくさん検査するといったテストが多く、読んでもよくわからないみたいなことになっています。
それでもテストも `describe("", ()=>{})` といった表記で behavior は書かれているので、その関数が何をしているかという雰囲気は掴みやすいです。

経験上、OSS はコメントが書かれているものより、書かれていないものが多く、コードを読むしかないのですが、テストには自然言語があるので、コードを読めなくてもそこから処理の内容が読めたりするといったことがあります。

## 経験として学んだ読み方

### 1 ファイルに 1 クラスファイルと思わない

普段アプリケーションコードを書くときは 1 ファイルに 1 機能のコードです。
フロントであれば UI コンポーネント一つが 1 ファイルだし、バックエンドなら関心事一つが 1 ファイルとして作ることが多いと思います。（もちろん InnerClass を使ったパターンなどもあるとは思いますが、数としては少ないはずです。）
しかしどうもライブラリのコードはそうはいかず、1 ファイルに複数クラスが入っていることがあります。
ファイル名だけを見て処理を予測して読んでいると、その該当処理を見つけられなかったりもするので、もし該当処理を見つけられないときはファイル内に複数のクラスがあったりしないかなと疑うと良いでしょう。

### new でインスタンスが作られるとは限らない

大規模なライブラリはよく クラスが使われています。
そして DI されてることが多いです。
なので基本的には new () を探せばいいのですが、そんな簡単にはいきません。

#### static factory patern

ライブラリによっては constructor が private になっていて代わりに of() などが使われています。
new で全文検索しても出てこないので注意しましょう。

#### module import で instance 化

VSCode の register

### code jump できないときに mixin を疑う

JS では mixin ができます。

それは Object.assign を使います。

それは code j

### 些末な関数は無視する

わからない処理があっても大事そうでないところは全部飛ばしています。
ライブラリを作る知識を学ぶという点では学べるところが多いと思いますが、ライブラリが内部のエッセンスみたいなのをみるだけなら飛ばしていいと思います。
目的意識をもって読むことが大事です。

ただ個人的にはライブラリは高階関数の使い方が上手いなといういつも関心します。
設定を返す関数を作るパターンというのがよく出てきます。
慣れないうちは読みにくいものなのでこれも飛ばすと良いでしょう。

## 最後に

ライブラリを読むって最初はすごい難しそうなイメージがあったのですが、いざやってみると意外といけました。
ライブラリは魔法の箱と思わずに、私たちが書くコードと同じものだという意識と、読み方のコツみたいなのを知っていると意外とすいすい読めたりします。
